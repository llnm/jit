<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>DAEYEON JIT</title>
    <link>https://llnm.github.io/</link>
    
    <atom:link href="https://llnm.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>컴퓨터 기술 분야를 연구하며 그 과정에서 얻은 것들을 공유합니다. 현재는 웹 관련 기술, 특히 Node.js 같은 자바스크립트 런타임에 관심이 많습니다.</description>
    <pubDate>Wed, 29 Nov 2023 13:01:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>WebAssembly 기술 동향</title>
      <link>https://llnm.github.io/article/2023-11-27-wasm/</link>
      <guid>https://llnm.github.io/article/2023-11-27-wasm/</guid>
      <pubDate>Sun, 26 Nov 2023 15:30:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;WebAssembly-WASM&quot;&gt;&lt;a href=&quot;#WebAssembly-WASM&quot; class=&quot;headerlink&quot; title=&quot;WebAssembly (WASM)&quot;&gt;&lt;/a&gt;WebAssembly (WASM)&lt;/h2&gt;&lt;p&gt;웹어셈블리(WebA</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="WebAssembly-WASM"><a href="#WebAssembly-WASM" class="headerlink" title="WebAssembly (WASM)"></a>WebAssembly (WASM)</h2><p>웹어셈블리(WebAssembly 또는 Wasm)는 다양한 프로그래밍 언어와 많은 실행 환경사이의 중간 계층으로, 30여 가지 이상의 언어로 작성된 코드를 .wasm 파일로컴파일한 다음 브라우저나 다른 실행 환경에서 실행할 수 있다. 원래 웹에서 코드실행 속도를 높이기 위해 개발되었지만 이제는 브라우저 이외의 다양한 환경에서도실행할 수 있다.</p><p><img src="https://www.w3.org/comm/assets/logos/web-assembly-logo-black-150px.png"></p><p>WebAssembly는 발표된 시점에 비해 널리 사용되지 않았는데, 우선 언어 간 상호호환성, 부족한 개발자 경험이 문제가 있었다. 또한 WebAssembly라는 이름 자체가웹이나 어셈블리에 국한되지 않는데, Web이란 키워드를 쓰면서 잘못된 인상을 주었다.</p><p>이에 ’19년 모질라, 레드햇, 인텔, Fastly. 등의 회사들이 커뮤니티를 (BytecodeAlliance) 구축하였고, 브라우저를 벗어난 웹어셈블리 런타임에 대한 표준과 도구를개발을 시작하였다. 현재 WASI (WebAssembly System Interface)를 구현한 WASM런타임을 제공하고 있다.</p><h3 id="특징"><a href="#특징" class="headerlink" title="특징"></a>특징</h3><ul><li>이식성 (Portable) - 한번 빌드하면 여러 플랫폼에서 활용가능</li><li>범용성 (Universal) - 많은 언어가 WASM으로 컴파일 가능</li><li>빠른 시작 시간 - Docker보다 10~100x 빠른 시작시간</li><li>안전성 (Secure) - 메모리 샌드박싱, 기능 제한</li><li>성능 - 네이티브에 가까운 성능 (1.5배 느림), JavaScript 보다는 항상 빠름</li></ul><h3 id="적용-예"><a href="#적용-예" class="headerlink" title="적용 예"></a>적용 예</h3><p>웹어셈블리의 적용 범위는 컨테이너화, 플러그인 시스템, 서버리스 컴퓨팅 플랫폼 등기술 영역에서의 활발한 활용된다. 또한, 보안 측면에서도 샌드박스화된 외부라이브러리의 안전한 실행, 제한된 권한 시스템, 그리고 라이브러리 격리 능력 등이포함된다.</p><ul><li>WASM 적용 범위 참고: <a href="https://harshal.sheth.io/2022/01/31/webassembly.html">https://harshal.sheth.io/2022/01/31/webassembly.html</a></li></ul><h2 id="WASI-WebAssembly-System-Interface"><a href="#WASI-WebAssembly-System-Interface" class="headerlink" title="WASI (WebAssembly System Interface)"></a>WASI (WebAssembly System Interface)</h2><p>WASI(WebAssembly System Interface)는 웹 어셈블리 애플리케이션이 호스트 시스템과상호 작용할 수 있도록 하는 표준 인터페이스이다. 이를 통해 웹 어셈블리애플리케이션은 파일 시스템, 네트워킹 등의 시스템 리소스에 접근하도록 되었다.</p><p>WASI가 등장하기 이전에는 Emscripten이 사용되었으며 자체적으로 JavaScript layer와WASM layer로 구성해 브라우저와 통신해서 시스템 기능을 사용하였다. de-facto표준으로 다뤄지나 속도나, Private API 사용등의 문제가 있다.(<a href="https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/">https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/</a>)</p><h3 id="WASI-사용-모듈과-Node-js-모듈-비교"><a href="#WASI-사용-모듈과-Node-js-모듈-비교" class="headerlink" title="WASI 사용 모듈과 Node.js 모듈 비교"></a>WASI 사용 모듈과 Node.js 모듈 비교</h3><ul><li><p>Portability: WASM 모듈은 Write one time, Use everywhere이 고려되었다. Node.jsNative 모듈이 환경마다 node-gyp를 통해 빌들을 수행하는 것에 비해 한번 빌드된형태로 그대로 배포가 가능하다.</p></li><li><p>Security: Capability-based security 전략을 사용한다. &quot;권한이 프로그램 단위가아니라 모듈 단위&quot;로 이루어지고, 모듈 단위로 전파될 때 권한에 대한 수정도가능하다. Node.js에서도 Permission 모델이 구축되고 있지만, 런타임 단위의보안을 제공하고 모듈 단위의 제어는 불가하다. (관련된 Node.js 해킹사례:electron-native-notify NPM 모듈의 ZipSlip)</p></li></ul><blockquote><p>Capability-based security 전략에서 각각의 개체(사용자, 프로세스, 모듈 등)는자신이 필요로 하는 특정한 능력을 가지고 있어야만 특정 능력을 수행할 수 있다.예를 들어, 파일에 액세스해야 하는 함수를 호출하는 경우, 해당 함수는 파일에대한 적절한 권한이 부여된 능력을 가진 객체에게만 실행되도록 할 수 있다. 이를통해 권한이 필요한 동작을 수행하는 데 필요한 최소한의 권한만 부여할 수 있게되며, 보안을 강화할 수 있다.</p></blockquote><p>3rd party NPM 모듈 Vulnerability를 보장할 수 없기 때문에 Node.js 런타임은 실제Production 에서 사용되기기 어렵다. 이에 비해 WASM 모듈은 WASI 인터페이스가Sandboxing을 고려하여 설계되어있다.</p><h3 id="표준화"><a href="#표준화" class="headerlink" title="표준화"></a>표준화</h3><p>현재 WASI의 모든 API는 Proposal 단계 (Phase 2) 이다. 아직 실험적 상태에고인터페이스가 변경이 가능함을 의미한다. 자세한 현황은<a href="https://github.com/WebAssembly/WASI/blob/main/Proposals.md">https://github.com/WebAssembly/WASI/blob/main/Proposals.md</a> 를 참조할 수 있다.</p><h3 id="WASM-Runtime-현황"><a href="#WASM-Runtime-현황" class="headerlink" title="WASM Runtime 현황"></a>WASM Runtime 현황</h3><p>브라우저 외부에서 WASM을 사용할 수 있는 Runtime은 다음과 같다.</p><ul><li><p>Bytecode Alliance, Standalone Runtime</p><ul><li>wasmtime: WSAM Standalone Runtime, wasi-core, (Standard compliant),브라우저용 WASI Polyfill,</li><li>WAMR (WebAssembly Micro Runtime): Binary size  85K (interpreter) and 50K(AOT) and low memory usage</li></ul></li><li><p>QuickJS 기반 JS 인터페이스 제공</p><ul><li>Wasmer (<a href="https://medium.com/wasmer/wasmer-1-0-3f86ca18c043">https://medium.com/wasmer/wasmer-1-0-3f86ca18c043</a>)</li><li>WASMedge (<a href="https://wasmedge.org/">https://wasmedge.org</a>)<ul><li>CJS NPM 모듈은 rollup.js을 통해 번들링하여 사용,<a href="https://wasmedge.org/book/en/write_wasm/js/tensorflow.html">https://wasmedge.org/book/en/write_wasm/js/tensorflow.html</a></li></ul></li></ul></li><li><p>Cloudflare</p><ul><li>Workerd (<a href="https://github.com/cloudflare/workerd">https://github.com/cloudflare/workerd</a>)</li><li>Workers 서비스의 Core, 분산 컴퓨팅 Microservice 운용에 특화</li></ul></li><li><p>Node.js</p><ul><li>WASI: application&#39;s sandbox directory structure, stdio&#x2F;out&#x2F;stderr 제공(Experimental) <a href="https://webassembly.org/roadmap/">https://webassembly.org/roadmap/</a></li></ul></li><li><p>Web Container</p><ul><li>WASM으로 Node.js 개발환경을 아에 제공. JS를 직접 돌림. Node 14. 지원</li><li><a href="https://github.com/stackblitz/webcontainer-core">https://github.com/stackblitz/webcontainer-core</a></li></ul></li><li><p>Blazor</p><ul><li>Flutter 같은 웹 F&#x2F;W, C# 기반으로 작성, 브라우저에서는 WASM을 이용</li></ul></li></ul><h2 id="Containerization"><a href="#Containerization" class="headerlink" title="Containerization"></a>Containerization</h2><p>서버 어플리케이션 배포에 용이한 Docker에 비해 WASM은 콜드 스타트 ​​시간이10~100배 빠르며 메모리 사용량이 적고 뛰어난 보안 모델을 채용하고 있다.컨테이너가 아닌 WASM 모듈이 연산 및 배포의 최소 단위가 될 가능성이 높으나,한번에 Docker를 완전히 대체하지는 않고 기존 오케스트레이션 시스템에 통합되는형태로 진행될 것이라 예측된다.</p><p>이러한 흐름과 별개의 Containerization 기술은 아래와 같다.</p><h3 id="Lightweight-Virtualization"><a href="#Lightweight-Virtualization" class="headerlink" title="Lightweight Virtualization"></a>Lightweight Virtualization</h3><p>Lightweight Virtualization은 전통적인 가상화 기술과는 다르게 더 가벼운 방식으로가상화를 구현하는 기술을 말한다. 더 적은 오버헤드와 빠른 부팅 시간을제공하면서도 격리와 보안을 유지한다. AWS Firecracker가 이러한 LightweightVirtualization 기술의 한 예로, 멀티 테넌시 환경에서 안전하게 컨테이너를실행하도록 되어있다. KVM(Kernel-based Virtual Machine)을 기반으로 하며, 커널기능을 최소화하여 경량화된 가상화를 제공한다.</p><ul><li>참고자료: <a href="https://www.koyeb.com/blog/lightweight-virtualization-the-container-ecosystem-and-firecracker-microvms-for-serverless">https://www.koyeb.com/blog/lightweight-virtualization-the-container-ecosystem-and-firecracker-microvms-for-serverless</a></li></ul><h3 id="JavaScript-Container"><a href="#JavaScript-Container" class="headerlink" title="JavaScript Container"></a>JavaScript Container</h3><p>JavaScript Container는 Node.js의 한계와 함께 등장한 새로운 개념으로, 브라우저API 디자인 개념을 공유함으로써 웹 개발자들이 JavaScript 런타임을 사용할 때배워야 할 개념을 줄일 수 있는 장점을 갖는다. 또, 메모리 사용량보다는 인스턴스사용 시간이 중요한 Serverless 환경에서 빠른 재구동 시간을 제공하여 비용을 절감할수 있다. 기존의 Microservice 아키텍처를 더 작은 단위의 컴포넌트로 분리하는새로운 애플리케이션 아키텍처 구축이 가능하다. (Linux Container를 대체하는 것이아니라 고성능 및 경량을 요구하는 일부 분야에서 광범위한 애플리케이션 적용 예상)</p><ul><li><p>예: CloudFlare Worker (JS Container &#x2F; Worker, v8::Isolate)</p><ul><li>Node.js 가 개별 장치의 앱 제작을 위해 만들어졌다면 Worker는 CloudFlare 특화 분산 네트웍 컴퓨팅을 위해 만들어짐</li><li><a href="https://developers.cloudflare.com/workers">https://developers.cloudflare.com/workers</a></li></ul></li><li><p>예: Deno deploy (JS Container)</p><ul><li>Web Platform APIs 기반, 프로그래머가 알아야 할 개념들을 최소화 + SingleExecutable, No NPM, TypeScript, CLI</li><li><a href="https://deno.land/">https://deno.land</a></li><li><a href="https://tinyclouds.org/javascript_containers">https://tinyclouds.org/javascript_containers</a></li></ul></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://webassembly.org/">https://webassembly.org</a></li><li><a href="https://bytecodealliance.org/">https://bytecodealliance.org</a></li><li><a href="https://harshal.sheth.io/2022/01/31/webassembly.html">Pay attention to WebAssembly</a></li><li><a href="https://www.yieldcode.blog/post/native-rust-wasm/">NodeJS Native Module vs WASM</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-11-27-wasm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>JavaScript Object의 생명주기 관리</title>
      <link>https://llnm.github.io/article/2023-11-26-js-object-lifetime/</link>
      <guid>https://llnm.github.io/article/2023-11-26-js-object-lifetime/</guid>
      <pubDate>Sat, 25 Nov 2023 15:30:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;Node.js Core 에서 JavaScript 생명주기를 관리하는 방법을 알기 위해서는 V8 API를
통해 메모리를 관리하는 컨셉을 이해할 필요가 있다. 모든 JavaScript 값은 V8 API를
통해 소위 핸들이라는 것을 통해 액세스된다. </description>
        
      
      
      
      <content:encoded><![CDATA[<p>Node.js Core 에서 JavaScript 생명주기를 관리하는 방법을 알기 위해서는 V8 API를통해 메모리를 관리하는 컨셉을 이해할 필요가 있다. 모든 JavaScript 값은 V8 API를통해 소위 핸들이라는 것을 통해 액세스된다. 이 핸들은 메모리 관점에서 Local과Global이란 타입으로 나뉜다.</p><h2 id="메모리-관리-타입"><a href="#메모리-관리-타입" class="headerlink" title="메모리 관리 타입"></a>메모리 관리 타입</h2><h3 id="v8-Local"><a href="#v8-Local" class="headerlink" title="v8::Local"></a>v8::Local</h3><p><code>v8::Local</code> 이란 JavaScirpt 값이 다뤄지는 현재의 Local Block 영역 (Stack) 에서만유효한 핸들을 의미한다. Local Block을 벗어나면 값은 유효하지 않게 된다. 값이Referencing 되고 있는지에 따라 GC (Gabage Collector)를 수행하는 JavaScript 엔진측면에서 메모리 관리는 중요한데, 기본적으로 C++ 에서 모든 JavaScript 값에 대해서Local 핸들로서 관리함으로서 메모리의 leak을 방지한다. 즉 임시적으로 사용할 메모리는 모두Local 핸들로서 직관적으로 다뤄진다.</p><p><code>v8::Local</code> 은 JavaScript 핸들이 어떤 메모리 영역에서 관리되야하는지를 나타내는Reference일 뿐 Local 메모리 생성을 의미하지는 않는다. Local 핸들을 생성하기위해선 Stack 영역에 <code>v8::HandleScope</code> 또는 <code>v8::EscapableHandleScope</code> 객체를생성해야한다. 생성된 이후 <code>Local::New</code> API를 사용하면 실제 Local 메모리에 적재된JavaScript 값을 생성할 수 있고 마지막으로 생성한 Scope 객체에 메모리 영역이잡히게 된다. 그러나 Node.js 에서 바인딩 함수 내부에 있는 경우는 Handle의 범위가함수 외부에 이미 존재하므로 별도로 만들 필요가 없다.</p><p><code>v8::EscapableHandleScope</code>는 Scope 내에서 생성된 <code>v8::Local</code>을 Scope 외부로넘기고자할때 사용할 수 있다. <code>v8::EscapableHandleScope</code> 객체의 <code>Escape</code> API로생성한 <code>v8::Local</code> 인스턴스를 넘기면 해당 영역 외부의 메모리 Scope로 전달된다.</p><h3 id="v8-Global"><a href="#v8-Global" class="headerlink" title="v8::Global"></a>v8::Global</h3><p>특정 Scope내에서만 유요한 <code>v8::Local</code>과 다르게 다르 <code>v8::Global</code> 로 관리되는핸들은 Scope와 관계없이 유지되며 GC 대상이 되지 않을 수 있다. 정확히 말하면Global 핸들의 Strong 상태에서 GC 되지 않는다. Global 핸들은 Weak 상태로 변경할수 있으며, Weak 상태가 되었을 때 GC 메카니즘에 의해 메모리가 릴리즈 될 수 있다.그런데, 그냥 릴리즈 되는 것이 아니라 GC 메카니즘에 의해 메모리 릴리즈 되기직전에 등록된 Callback을 통해 통보받는다. 그 시점에서 다시 Strong으로 변경할지Weak를 유지하여 릴리즈를 할지 결정이 가능하다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(v8::Isolate* isolate, v8::Local&lt;v8::Object&gt; obj)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Global의 Reset() 함수를 이용하여 Local 영역에 있는 obj 핸들을 Global로 이동시킨다.</span></span><br><span class="line">  <span class="comment">// 이동이 되면 기본적으로 Strong 상태로 핸들을 관리한다.</span></span><br><span class="line">  v8::Global&lt;v8::Object&gt; reference = reference.<span class="built_in">Reset</span>(isolate, obj);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="생명주기-관리"><a href="#생명주기-관리" class="headerlink" title="생명주기 관리"></a>생명주기 관리</h2><p>JavaScript 엔진은 Gabage Collector를 주기적으로 실행하여 어떤 객체도Referencing하지 않는 객체에 대해 제거한다. 사용자가 JavaScript 객체를Referencing 하지 않더라도 Core는 필요에 따라 특정 JavaScript 객체가 엔진에 의해제거되는 것을 방지해야한다. 그렇게 하기 위해서 JavaScript Object의<code>InternalField</code> 에 C++ 클래스 인스턴스를 저장하고, JavaScript Object에 대한메모리 영역을 Local에서 Global로 변경한다. 이 동작은 Node.js에서 객체와바인딩되는 모든 Class의 부모 Class인 <code>BaseObject</code> 의 생성자에서 수행된다.<code>v8::Global&lt;v8::Object&gt;</code> 타입 변수 <code>persistent_handle_</code>에 Local 객체를등록함으로서 상기 Code에서 <code>Reset</code>을 호출한것과 같이 Global 메모리 영역으로JavaScript 값을 이동시킨다.</p><h3 id="Weak-상태로-변경"><a href="#Weak-상태로-변경" class="headerlink" title="Weak 상태로 변경"></a>Weak 상태로 변경</h3><p><code>v8::Global</code>의 <code>SetWeak</code> API는 현재 Strong으로 관리되고 있는 메모리를 Weak상태로 변경함으로서 GC 시 메모리를 릴리즈 할 수 있게 한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BaseObject::MakeWeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  persistent_handle_.<span class="built_in">SetWeak</span>(</span><br><span class="line">      <span class="keyword">this</span>, <span class="comment">// (a) Callback으로 전달할 포인터</span></span><br><span class="line">      [](<span class="type">const</span> WeakCallbackInfo&lt;BaseObject&gt;&amp; data) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// (a) 에서 전달한 BaseObject 포인터를 parameter로서 획득한다.</span></span><br><span class="line">        BaseObject* obj = data.<span class="built_in">GetParameter</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">          ~BaseObject에서 internal field를 clean up 하는 부분이 있는데</span></span><br><span class="line"><span class="comment">          GC에 의해 삭제된 경우는 굳이 해당 동작을 하지 않도록 한다.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        obj-&gt;persistent_handle_.<span class="built_in">Reset</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// BaseObject 인스턴스가 연결되어있던 JavaScript 객체는 이제 삭제되니, 이</span></span><br><span class="line">        <span class="comment">// BaseObject도 삭제되어야한다. OnGCCollect 함수에서는 delete this를 수행한다.</span></span><br><span class="line">        obj-&gt;<span class="built_in">OnGCCollect</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// (b) Callback에 전달 가능한 타입은 kParameter 와 kInternalFields 이며</span></span><br><span class="line">      <span class="comment">// kInternalFields 타입은, 지정된 internal field의 첫 두 field를 전달한다.</span></span><br><span class="line">      WeakCallbackType::kParameter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상기 코드는 BaseObject의 MakeWeak함수의 일부이다. SetWeak를 통해 GC 발생시점에콜백을 등록하고 Strong 에서 Weak 핸들로 변경한다. 자바스크립트 객체가 가비지컬렉션되기 전에 등록된 콜백이 호출된다. <code>BaseObject::OnGCCollect()</code>를 호출하면BaseObject 인스턴스가 삭제된다. SetWeak 등록된 후 <code>BaseObject::ClearWeak()</code>를호출하여 Strong상태로 다시 변경할 수 있다.</p><p>일반적으로 해당 서브클래스가 이벤트 루프 등에서 참조되지 않는 한, HandleWrap 및ReqWrap 클래스의 경우처럼 해당 서브클래스의 생성자에서 MakeWeak()를 호출하는것이 합리적입니다.</p><h3 id="Smart-Pointer-for-BaseObject"><a href="#Smart-Pointer-for-BaseObject" class="headerlink" title="Smart Pointer for BaseObject"></a>Smart Pointer for BaseObject</h3><h4 id="BaseObjectPtr"><a href="#BaseObjectPtr" class="headerlink" title="BaseObjectPtr"></a>BaseObjectPtr<T></h4><p>BaseObject의 서브클래스 T의 객체를 Shared Pointer로서 보유한다. 즉, 이 포인터를가지고 있는동안은 BaseObject는 Strong 참조를 유지한다.</p><p>BaseObject는 JavaScript 객체의 생명주기를 따르나 <code>Detach()</code>가 호출된다면 BaseObject를JavaScript 객체의 생명주기로 부터 분리해낼수 있다. 이 경우 <code>BaseObjectPtr</code> 를 참조하는마지막 포인터가 제거되면 BaseObject는 릴리즈된다.</p><h4 id="BaseObjectWeakPtr"><a href="#BaseObjectWeakPtr" class="headerlink" title="BaseObjectWeakPtr"></a>BaseObjectWeakPtr<T></h4><p>BaseObject의 서브클래스 T의 객체를 Weak Pointer로서 보유한다. Garbage Collection이발생해 BaseObject가 제거되면 <code>std::weak_ptr&lt;T&gt;</code>와 유사하게 <code>weak_ptr.get()</code>의값으로 nullptr가 반환된다.</p><h3 id="v8-State-transition-diagram"><a href="#v8-State-transition-diagram" class="headerlink" title="v8: State transition diagram"></a>v8: State transition diagram</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">FREE -&gt; NORMAL &lt;-&gt; WEAK -&gt; PENDING -&gt; NEAR_DEATH -&gt; &#123; NORMAL, WEAK, FREE &#125;</span><br></pre></td></tr></table></figure><img class="kroki" src="https://kroki.io/plantuml/svg/eNqL1opV0NW1UwgOCfL3c-dSLMlIzU1VKMhJzMzjgogp6BZlpmeUANWEuzp6K1gp-CZmp4anJmZzgfm6OalpJXADgNLOOamJRUjyMN3-eW6ZeYk5mVWpKVxIbKDtYBOwG4GiEGoTyFhUCagV0VqxXFxgtkJafn5JapHCo8mTFIwMjIz1FDJKSgqKrfT1c3LycvXSM0sySpP0MvO5ADKMUR4=" />]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-11-26-js-object-lifetime/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js C++ Core Concept</title>
      <link>https://llnm.github.io/article/2023-11-24-memory-management/</link>
      <guid>https://llnm.github.io/article/2023-11-24-memory-management/</guid>
      <pubDate>Thu, 23 Nov 2023 15:30:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;JavaScript와 C++ 간의 효율적인 연결은 Node.js에서 중요한 문제 중 하나이다.
이러한 연결을 가능하기 위해 Node.js Core에서는 기본 C++ 클래스로 BaseObject
사용한다. BaseObject는 JavaScript </description>
        
      
      
      
      <content:encoded><![CDATA[<p>JavaScript와 C++ 간의 효율적인 연결은 Node.js에서 중요한 문제 중 하나이다.이러한 연결을 가능하기 위해 Node.js Core에서는 기본 C++ 클래스로 BaseObject사용한다. BaseObject는 JavaScript 객체와 C++ 객체를 함께 묶는 주요 추상화수단으로, 이를 통해 메모리 관리와 더불어 객체의 수명 주기를 관리할 수 있다.</p><h2 id="BaseObject"><a href="#BaseObject" class="headerlink" title="BaseObject"></a>BaseObject</h2><p>Node.js에서 JavaScript 객체와 연관된 대부분의 클래스는 <code>BaseObject</code> 의subclass이다. BaseObject의 상위 클래스는 MemoryRainer인데, V8 Heap snapshotbuilder에서 메모리 추적을 위해 C++ 클래스에 Annotation을 할 수 있도록 하는Helper 클래스라고 한다. 메모리 릭에 대한 디버깅 용도로 사용할 수 있다.</p><img class="kroki" src="https://kroki.io/plantuml/svg/eNqtUk1v00AQve-veFxQEiUpKheUREhQqagSiEhU4hiN7Wm9eLJjebdBfPRPwD_kl3TXbozb5NBDT54vv33vzQC-sq6mhrYQ6zj8qBnahFLNi1DyllELWWew5sZbH9iF9-QZq9-zGT6IZiQGuzdYxfThiMFXpuqMRDLKq8uEe2yow8BMZopU-Zx94zwYXHgVCkf_MciFvH9M6ZcBdmoLfOGQnh6tJ2iFceBmij0T5PfB9JBgUj_ew5wJU9MCpVKmKpFUn19OsCPZGNxGPuxutodoiVC13jNIyYWLgSM5tyyFT5VzG1P7M7VvDZxGxUFr6NUh3GIAhu9WJKqLLlDLdiAVrcqgiPvrxfamxV31Rn2iiltB74qiYe8noC6Y4jm9iw51b__fb8vBunRxkdFi8VEj8ipFXf8ttP2OxsjV-bB84ngq3V_OBLYLjkN0dzfEeIm6P6jReGkG8w_MGi8fdQZiU-s4-gB8U5IrhDdLE51p7HUZcKWaNvfv7x-cvjp9PUcZQu0XJycibju_tqG8yeZWzR3jszw1" /><p>모든 BaseObject는 하나의 Realm과 하나의 <code>v8::Object</code> 와 연관된다. <code>v8::Object</code>클래스는 JavaScrip Object를 뜻한다. 이 클래스의 인스턴스에는 internal field라고하는 공간을 할당할 수 있다. 이 공간에 BaseObject의 나 하위 Class의 포인터를연결함으로서 JavaScript Object 와 C++ 클래스 인스턴스를 바인딩한다. InternalField에 반드시 BaseObject의 서브클래스만 등록해야하는 것은 아니다.InternalField에 얼마나 많은 정보를 넣을지는 V8 API의 <code>SetInternalFieldCount()</code>를 통해 설정할 수 있다.</p><figure class="highlight cc"><figcaption><span>base_object.cc</span><a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/src/base_object.cc">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">BaseObject::<span class="built_in">BaseObject</span>(Realm* realm, Local&lt;Object&gt; object)</span><br><span class="line">    : <span class="built_in">persistent_handle_</span>(realm-&gt;<span class="built_in">isolate</span>(), object), <span class="built_in">realm_</span>(realm) &#123;</span><br><span class="line">  <span class="built_in">CHECK_EQ</span>(<span class="literal">false</span>, object.<span class="built_in">IsEmpty</span>());</span><br><span class="line">  <span class="built_in">CHECK_GE</span>(object-&gt;<span class="built_in">InternalFieldCount</span>(), BaseObject::kInternalFieldCount);</span><br><span class="line">  <span class="built_in">SetInternalFields</span>(realm-&gt;<span class="built_in">isolate_data</span>(), object, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  realm-&gt;<span class="built_in">AddCleanupHook</span>(DeleteMe, <span class="built_in">static_cast</span>&lt;<span class="type">void</span>*&gt;(<span class="keyword">this</span>));</span><br><span class="line">  realm-&gt;<span class="built_in">modify_base_object_count</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>상기 BaseObject 생성자 함수에서 확인 할 수 있듯이 <code>SetInternalFields</code> 를 이용해Local 메모리 영역의 object에 BaseObject 인스턴스 자신 (this) 를 설정한다.</p><h3 id="Accessing-BaseObject"><a href="#Accessing-BaseObject" class="headerlink" title="Accessing BaseObject"></a>Accessing BaseObject</h3><p>C++레벨에서 JavaScript Object로 부터 BaseObject에 대한 포인터를 얻는 방법은<code>Unwrap&lt;T&gt;</code> 를 사용한다. 보통 JavaScript 객체의 Function Callback의 호출되었을때<code>arg.This()</code> 나 <code>arg.Holder()</code> 로 부터 얻을수 있다. (args.Holder()는 Node.js내부의 모든 사용 사례에서 args.This()와 동일).</p><p><code>Unwrap&lt;T&gt;()</code> 는 반환받는 Pointer를 미리 Casting하려는 용도의 Alias 함수이다.내부적으로는 <code>BaseObject::FromJSObject</code> 에 의해서 v8::Object부터 기 지정한internal field로 부터 Pointer를 얻어온다.</p><figure class="highlight h"><figcaption><span>base_object.h</span><a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/src/base_object.h">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...)                                 \</span></span><br><span class="line"><span class="meta">  do &#123;                                                                         \</span></span><br><span class="line"><span class="meta">    *ptr = static_cast<span class="string">&lt;typename std::remove_reference&lt;decltype(*ptr)&gt;</span>::type&gt;(  \</span></span><br><span class="line"><span class="meta">        BaseObject::FromJSObject(obj));                                        \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> (*ptr == nullptr) return __VA_ARGS__;                                   \</span></span><br><span class="line"><span class="meta">  &#125; while (0)</span></span><br></pre></td></tr></table></figure><h3 id="AsyncWrap"><a href="#AsyncWrap" class="headerlink" title="AsyncWrap"></a>AsyncWrap</h3><p>AsyncHook은 비동기 요청(init&#x2F;destory)의 수명 및 해당 콜백 활동(Before&#x2F;After)을추적하는 기능을 제공한다. 이를 위한 추가적인 정보와 도구를 제공하는 BaseObject의서브클래스가 AsyncWrap이다. AsyncHook에서 명시되었던 것과 같이 어떤 Core 모듈이해당 Async동작을 수행했는지를 추적하기 위한 unique id가 있다.</p><figure class="highlight h"><figcaption><span>async_wrap.h</span><a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/src/async_wrap.h">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NODE_ASYNC_NON_CRYPTO_PROVIDER_TYPES(V)                                \</span></span><br><span class="line"><span class="meta">  V(NONE)                                                                      \</span></span><br><span class="line"><span class="meta">  V(DIRHANDLE)                                                                 \</span></span><br><span class="line"><span class="meta">  V(DNSCHANNEL)                                                                \</span></span><br><span class="line"><span class="meta">  V(ELDHISTOGRAM)                                                              \</span></span><br><span class="line"><span class="meta">  V(FILEHANDLE)                                                                \</span></span><br><span class="line"><span class="meta">  V(FILEHANDLECLOSEREQ)                                                        \</span></span><br><span class="line"><span class="meta">  V(BLOBREADER)                                                                \</span></span><br><span class="line"><span class="meta">  V(FSEVENTWRAP)                                                               \</span></span><br><span class="line"><span class="meta">  V(FSREQCALLBACK)                                                             \</span></span><br><span class="line"><span class="meta">  V(FSREQPROMISE)                                                              \</span></span><br></pre></td></tr></table></figure><p>AsyncHook을 도입할때 비동기 연산에 대한 디버깅을 쉽게하기 위함이었을것 같다.(TODO: 향후 History를 찾으면 다시 업데이트 하겠다.) 그러나, 최근 FS 모듈에 대한Async File Read를 분석해보니 Tracing을 단일 Operation 단위로 처리될 수 있도록고정되어있어 통합된 비동기 동작에 대한 Tracing 처리를 만들기가 어려웠다. 또,Node.js 에서는 <a href="https://nodejs.org/api/async_hooks.html#async-hooks">공식적으로 AsyncHook에 대한 기능 사용을 권하지않는다</a>. 따라서, 향후 어떤방향이든 개선이 필요한 클래스이다.</p><p><code>AsyncWrap</code> 클래스에서 중요한 함수는 <code>MakeCallback</code>을 들수 있다. Callback을만들기 위한 함수명 처럼 보이지만 이름과는 다르게 실제의미는 C++에서 JavaScript쪽으로 Callback을 부르는 용도를 한다. 참고로 이러한 JavaScript와 C++ 사이의Context Switching이 일어나는 경우 Cost가 많이 들기 때문에 되도록 적게 부르는것이 Performance 측면에서 좋다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">StatWatcher::Callback</span><span class="params">(<span class="type">uv_fs_poll_t</span>* handle,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">int</span> status,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">uv_stat_t</span>* prev,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> <span class="type">uv_stat_t</span>* curr)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// StatWatcher 는 AsyncWrap의 서브 클래스</span></span><br><span class="line">  StatWatcher* wrap = <span class="built_in">ContainerOf</span>(&amp;StatWatcher::watcher_, handle);</span><br><span class="line">  Environment* env = wrap-&gt;<span class="built_in">env</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Integer::New 로 할당을 하기 때문에 HandleScope를 잡아준다.</span></span><br><span class="line">  <span class="function">HandleScope <span class="title">handle_scope</span><span class="params">(env-&gt;isolate())</span></span>;</span><br><span class="line">  <span class="function">Context::Scope <span class="title">context_scope</span><span class="params">(env-&gt;context())</span></span>;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="comment">// C++에서 JavaScript 쪽으로 전달할 argument</span></span><br><span class="line">  Local&lt;Value&gt; argv[] = &#123; Integer::<span class="built_in">New</span>(env-&gt;<span class="built_in">isolate</span>(), status), arr &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// wrap 인스턴스에 연결된 객체에 프로퍼티중 onchange 에 등록된 콜백을 호출</span></span><br><span class="line">  wrap-&gt;<span class="built_in">MakeCallback</span>(env-&gt;<span class="built_in">onchange_string</span>(), <span class="built_in">arraysize</span>(argv), argv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Libuv-Handlers"><a href="#Libuv-Handlers" class="headerlink" title="Libuv Handlers"></a>Libuv Handlers</h3><p>libuv에서 이벤트 루프와 상호작용하는 데 사용되는 타입이 있는데 handle과request이다.<a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/deps/uv/include/uv.h">uv.h</a>를살펴보면 아래와 같이 정의된 타입을 확인할 수 있다.</p><figure class="highlight h"><figcaption><span>uv.h</span><a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/deps/uv/include/uv.h">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Handle types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_loop_s</span> <span class="title">uv_loop_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_handle_s</span> <span class="title">uv_handle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_dir_s</span> <span class="title">uv_dir_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_stream_s</span> <span class="title">uv_stream_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tcp_s</span> <span class="title">uv_tcp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_s</span> <span class="title">uv_udp_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_pipe_s</span> <span class="title">uv_pipe_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_tty_s</span> <span class="title">uv_tty_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_poll_s</span> <span class="title">uv_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_timer_s</span> <span class="title">uv_timer_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_prepare_s</span> <span class="title">uv_prepare_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_check_s</span> <span class="title">uv_check_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_idle_s</span> <span class="title">uv_idle_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_async_s</span> <span class="title">uv_async_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_process_s</span> <span class="title">uv_process_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_event_s</span> <span class="title">uv_fs_event_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_poll_s</span> <span class="title">uv_fs_poll_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_signal_s</span> <span class="title">uv_signal_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Request types. */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_req_s</span> <span class="title">uv_req_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getaddrinfo_s</span> <span class="title">uv_getaddrinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_getnameinfo_s</span> <span class="title">uv_getnameinfo_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_shutdown_s</span> <span class="title">uv_shutdown_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_write_s</span> <span class="title">uv_write_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_connect_s</span> <span class="title">uv_connect_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_udp_send_s</span> <span class="title">uv_udp_send_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_fs_s</span> <span class="title">uv_fs_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_work_s</span> <span class="title">uv_work_t</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">uv_random_s</span> <span class="title">uv_random_t</span>;</span></span><br></pre></td></tr></table></figure><ul><li><p>Handle은 파일 디스크립터, 타이머, 혹은 다른 리소스와 관련된 이벤트를추적하는 데 사용된다. 이벤트 루프가 이러한 이벤트를 감지하고 처리할 수 있도록핸들을 등록하고 관리한다.</p></li><li><p>Request는 비동기 작업을 수행하고 완료되었을 때 결과를 처리하는 데 사용된다.파일 읽기, 쓰기, 혹은 네트워크 요청과 같은 작업을 수행할 때 request를 생성하여완료되었을 때의 콜백을 등록한다.</p></li></ul><h3 id="Libuv-Handle-Wrapper-Class"><a href="#Libuv-Handle-Wrapper-Class" class="headerlink" title="Libuv Handle Wrapper Class"></a>Libuv Handle Wrapper Class</h3><h4 id="HandleWrap"><a href="#HandleWrap" class="headerlink" title="HandleWrap"></a>HandleWrap</h4><p>HandleWrap은 AsyncWrap의 서브클래스이며 <code>uv_handle_t</code> 와 같은 libuv의 핸들을감싸서 관리하는 용도로 사용된다. <code>.ref()</code>, <code>.unref()</code>,<code>.hasRef()</code>,<code>.close()</code>등의 함수가 제공되는데, 함수 내부적으로 libuv의 <code>uv_ref()</code>, <code>uv_unref()</code> 와 같은API를 호출한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">HandleWrap::Ref</span><span class="params">(<span class="type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  HandleWrap* wrap;</span><br><span class="line">  <span class="built_in">ASSIGN_OR_RETURN_UNWRAP</span>(&amp;wrap, args.<span class="built_in">Holder</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">IsAlive</span>(wrap))</span><br><span class="line">    <span class="built_in">uv_ref</span>(wrap-&gt;<span class="built_in">GetHandle</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReqWrap"><a href="#ReqWrap" class="headerlink" title="ReqWrap"></a>ReqWrap</h4><p>ReqWrap AsyncWrap의 서브클래스이며 <code>uv_req_t</code> 와 같은 libuv의 request를 쉽게처리하는 기능을 제공한다. 예를들면 파일을 읽는 동작을 <code>uv_fs_t</code> request 핸들을이용하여 전달할때 요청된 동작이 끝나면 결과 Callback이 호출되도록 등록한다.</p><img class="kroki" src="https://kroki.io/plantuml/svg/eNptUt1u0zAUvvdTHMRNunXZNO6mUmkUFYHKj2Bil9GJc5qYunZqHweFjZeAN-RJcDqaZhk39jn6fnx-7DfK1OhwC1oZ4rYmsI4rK55xRVuCWqMyQlz71shbhzWchfrsfg6v0NPH_BtJFp9pN0R66hj4l3ZKsfwSsy4agQ_AArXOUW4OYM8WQmr0_vgG3AmA97ihgySR-VQZBnSlnHZnMxE_D7JBBXthoxwH1NBYVcACjSSdTOAlXAyw_qkTeEPcZz1vpTx_sAXNBuZzcLTLvscs2wUKlD0pYRaabO0znsNzrcqKZYsmlnQKr5WvkWWVrFQemmUwkpU1sDZTuHalT9O0a8oPmjqOstO_NYoTaY1nkBW6E_Ctl3E2U_DqB2UMmqIVmbCNh7SFMmUfjE37NdzFVXqrG0pWNprNvqIOscmmuyZwtZ9fp124tmb7zuZxcY-_whi5qRxh8clafWvdJtpjsVSa9oSx9j_gSH4Y7ZH3MNXSEcXP67oY1tYyOfjz-xdcXly-SKFirv3V-bnWZpuWiquQp8qKvxY1DAo=" /><p><code>ReqWrap::Dispatch()</code> 메서드는 이러한 동작을 일관된 방법으로 사용할 수 있게한다.</p><figure class="highlight h"><figcaption><span>req_wrap-inl.h</span><a href="https://github.com/nodejs/node/blob/f8c27e61761deffe1a20425c88d74afb830c33e4/src/req_wrap-inl.h">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename T&gt;</span><br><span class="line">template &lt;typename LibuvFunction, typename... Args&gt;</span><br><span class="line"><span class="type">int</span> ReqWrap&lt;T&gt;::Dispatch(LibuvFunction fn, Args... args) &#123;</span><br><span class="line">  Dispatched();</span><br><span class="line">  <span class="comment">// This expands as:</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// int err = fn(env()-&gt;event_loop(), req(), arg1, arg2, Wrapper, arg3, ...)</span></span><br><span class="line">  <span class="comment">//              ^                                       ^        ^</span></span><br><span class="line">  <span class="comment">//              |                                       |        |</span></span><br><span class="line">  <span class="comment">//              \-- Omitted if `fn` has no              |        |</span></span><br><span class="line">  <span class="comment">//                  first `uv_loop_t*` argument         |        |</span></span><br><span class="line">  <span class="comment">//                                                      |        |</span></span><br><span class="line">  <span class="comment">//        A function callback whose first argument      |        |</span></span><br><span class="line">  <span class="comment">//        matches the libuv request type is replaced ---/        |</span></span><br><span class="line">  <span class="comment">//        by the `Wrapper` method defined above                  |</span></span><br><span class="line">  <span class="comment">//                                                               |</span></span><br><span class="line">  <span class="comment">//               Other (non-function) arguments are passed  -----/</span></span><br><span class="line">  <span class="comment">//               through verbatim</span></span><br><span class="line">  <span class="type">int</span> err = CallLibuvFunction&lt;T, LibuvFunction&gt;::Call(</span><br><span class="line">      fn,</span><br><span class="line">      env()-&gt;event_loop(),</span><br><span class="line">      req(),</span><br><span class="line">      MakeLibuvRequestCallback&lt;T, Args&gt;::For(this, args)...);</span><br><span class="line">  <span class="keyword">if</span> (err &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    ClearWeak();</span><br><span class="line">    env()-&gt;IncreaseWaitingRequestCounter();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-11-24-memory-management/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Realm Class</title>
      <link>https://llnm.github.io/article/2023-11-23-realm/</link>
      <guid>https://llnm.github.io/article/2023-11-23-realm/</guid>
      <pubDate>Wed, 22 Nov 2023 15:30:20 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/NuZ8NoJ.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;2022년 Node.js 에는 Realm Class가 추가되었다. Realm은 주로 실행 환경을 정의하고
코드 간의 격리와 분리를 유지하기 위한 목적으로 </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://i.imgur.com/NuZ8NoJ.png"></p><p>2022년 Node.js 에는 Realm Class가 추가되었다. Realm은 주로 실행 환경을 정의하고코드 간의 격리와 분리를 유지하기 위한 목적으로 사용된다. 기존 Node.js VM 모듈이있으나 Node.js 자체 기능이고 JavaScript Object Graph가 노출될 가능성이 있다.그에비해 새롭게 도입된 Realm은 보안측면에서 강화된 JavaScript 실행환경을제공한다.</p><h2 id="ECMAScript-Realm"><a href="#ECMAScript-Realm" class="headerlink" title="ECMAScript Realm"></a>ECMAScript Realm</h2><h3 id="정의와-구성요소"><a href="#정의와-구성요소" class="headerlink" title="정의와 구성요소"></a>정의와 구성요소</h3><p>ECMAScript realm은 ECMAScript 스펙상의 개념이다. 이 용어는 코드 실행 컨텍스트,실행 환경 및 연관된 객체의 집합을 나타내는데, 간단히 말해서 코드가 실행되고변수, 함수, 객체 등이 존재하는 공간이라고 볼 수 있다. 다음은 Realm의 종류이다.</p><ul><li><p><strong>Principal Realm:</strong> 각각의 ECMAScript 실행 환경에서 하나씩만 존재하는 특수한Realm. 이 Realm은 주로 코드 실행에 사용되며, 전역 객체와 스코프를 포함하는주 실행 컨텍스트를 정의한다.</p></li><li><p><strong>Synthetic Realm:</strong> JavaScript 코드에서 명시적으로 생성되는 가상의 Realm.주로 코드 분리 및 격리를 위해 사용된다. 각 Synthetic Realm은 자체의 전역객체와 스코프를 갖고 있다. 모듈 시스템과 관련이 있어, 모듈 간의 격리를유지하고 코드의 독립성을 증가시키는 데 사용된다.</p></li></ul><p>ECMAScript realm은 구성 중 일부는 다음과 같다.</p><ul><li><strong>Global Object:</strong> 각 realm은 전역 객체를 가지고 있으며, 이 객체는 해당realm에 속한 모든 전역 변수와 함수를 포함함. 브라우저 환경에서는 <code>window</code>,Node.js에서는 <code>global</code>이 전역 객체에 해당한다.</li><li><strong>Global Scope:</strong> 전역 객체의 스코프에 속하는 변수와 함수는 전역 스코프에존재하며 realm 전체에서 접근 가능한 범위를 의미한다.</li><li><strong>Intrinsics:</strong> 각 realm은 특정한 빌트인 객체와 함수를 갖는다. <code>Object</code>나<code>Array</code>와 같은 객체 생성자들이 여기에 속한다.</li><li><strong>Declarative Environment Records:</strong> 변수 선언 등과 같은 정보를 저장하는 객체.</li><li><strong>Object Environment Records:</strong> 전역 객체 등과 같은 객체에 대한 참조를 유지하는 객체</li></ul><p>구성요소에 관한 더 상세한 내용은 아래 링크를 참조한다.</p><ul><li><a href="https://tc39.es/ecma262/#sec-code-realms">ECMAScript® 2024 Language Specification (tc39.es)</a></li></ul><h3 id="Realm-Class"><a href="#Realm-Class" class="headerlink" title="Realm Class"></a>Realm Class</h3><p>Node.js 에서 Realm 클래스는 특정 ECMAScript 영역과 연관된 JavaScript 객체 및함수 집합을 위한 컨테이너이다. 각 ECMAScript 영역에는 Global Object와 Intrinsics집합이 있다. ECMAScript 영역에는 <code>[[HostDefined]]</code> 필드가 있으며, 이 필드는Node.js 영역 객체를 나타낸다.</p><p>모든 Realm 인스턴스는 Context에서 생성된다. Node.js 내에서 Realm 은 본 개념과같이 principal realm 과 synthetic realm으로 생성될 수 있다. principal realm는<code>Node::Environment</code>의 main Context에서 생성된다. synthetic realm은 ShadowRealm의Context (JavaScript API에 의해 생성됨) 에 대해 생성된다. vm.Context에는 Realminstance를 생성하지 않는다.</p><img class="kroki" src="https://kroki.io/plantuml/svg/eNptjk1qAkEQRvd9iopLoWf82YWQjWQZED1B61SmC7urmpoyQfAUekNP4jBK0JD1e-_j63bEJWjIkIjRDgVB1KK4F4uYEUoKxK77tTZhu2tV9twsJImCaeCuR8jm3Cdm0cMKrW9Q4e3oGw8rDCn_jz74m1Q4D_Hg3cFSibdUQrrFD8jDOoZGfm7APSzAaDoCr_79b_3kjHtnkJ5mlNpo8CVi_bfL-QSzyWxeQTQr3Wtdp8S5asniflORuCuJm2t7" /><h2 id="ShadowRealm을-이용한-Isolation"><a href="#ShadowRealm을-이용한-Isolation" class="headerlink" title="ShadowRealm을 이용한 Isolation"></a>ShadowRealm을 이용한 Isolation</h2><p>Node.js 가 도입한 내용은 Synthetic Realm을 이용한 객체 참조 (Object Graph) 의격리를 보장하는 것이다. 아래의 예를 들면 (1) 에서 vm에서 생성된 함수가 외부의객체를 접근할 수 있는데 이러한 참조를 Synthetic Realm을 통해 격리시킬 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ctx = vm.<span class="title function_">createContext</span>();</span><br><span class="line"><span class="keyword">let</span> fn = vm.<span class="title function_">runInContext</span>(<span class="string">&#x27;...&#x27;</span>, ctx);</span><br><span class="line"></span><br><span class="line"><span class="title function_">fn</span>(&#123;&#125;); <span class="comment">// &lt;= (1) vm에서 생성된 함수가 외부 `Object`에 액세스하여 메서드에 접근할수 있다.</span></span><br></pre></td></tr></table></figure><h3 id="ShadowRealm"><a href="#ShadowRealm" class="headerlink" title="ShadowRealm"></a>ShadowRealm</h3><ul><li><a href="https://github.com/tc39/proposal-shadowrealm">tc39&#x2F;proposal-shadowrealm: ECMAScript Proposal, specs, and reference implementation for Realms (github.com)</a></li></ul><p>Synthetic Realm을 생성하기 위해 Node.js는 TC39 3단계 제안상태인 ShadowRealm기능을 사용한다. ShadowRealm은 서로 다른 자바스크립트 실행 컨텍스트 간의 객체그래프 격리를 보장하고, 새로운 빌트인을 도입하여 별개의 글로벌 환경을 제공한다.또한 ShadowRealm은 사용하는 모듈 그래프가 외부 영역으로부터 격리되도록 보장한다.ShadowRealm은 모든 주요 영역 (main thread 환경 &#x2F; worker thread 환경), 다른ShadowRealm 및 vm.Context에서 생성할 수 있다. VM과 비교하면 ShadowRealm은 URL,TextEncoders 등과 같이 Node.js 에서 공통인 API가 내장되어 있다. 따라서 더 쉽게일반적인 JavaScript 코드를 실행할 수 있다.</p><p>Node.js 에서 Realm을 계층적으로 구조한 디자인을 정리하면 다음과 같다.</p><ul><li><p><strong>Environment</strong> (Main thread 나 Worker threads, ECMAScript<a href="https://tc39.es/ecma262/#sec-agents">agent</a>를 나타낸다)</p><ul><li>worker_contexts: worker 가 객체를 처리한다. handle objects.</li><li>principal_realm: principal realm (<code>v8::Context</code>) 과 관련된 데이터</li><li>synthetic_realms: Synthetic realms.</li><li>time origin.</li></ul></li><li><p><strong>Realm</strong> (realm record, principal realm, ShadowRealm, vm.Context):</p><ul><li>context: 실행 context.</li><li>principal realm을 나타내는 플래그</li><li>module map.</li><li>Per-context persistent handles.</li><li>… principal realm과 synthetic realm 간 공통인 데이터</li></ul></li></ul><p>각 Realm은 여러 개의 synthetic realm 을 생성할 수 있다. Realm의 도입으로<code>Node::Environment</code>는 이벤트 루프, Inspector 등 여러 Realm에서 공유할 수 있는기타 여러 가지를 소유하는 Thread&#x2F;Execution environment&#x2F;ECMAScript 에이전트의레코드로 해석할 수 있다.</p><h3 id="Bootstrapping-순서"><a href="#Bootstrapping-순서" class="headerlink" title="Bootstrapping 순서"></a>Bootstrapping 순서</h3><h4 id="node-Environment-Principal-realm-설정"><a href="#node-Environment-Principal-realm-설정" class="headerlink" title="node::Environment Principal realm 설정"></a><code>node::Environment</code> Principal realm 설정</h4><ol><li>InitializeContext<ul><li>internal&#x2F;per_context&#x2F;primordials</li><li>internal&#x2F;per_context&#x2F;domexception</li><li>internal&#x2F;per_context&#x2F;messageport</li></ul></li><li>Environment::RunBootstrapping<ul><li>internal&#x2F;bootstrap&#x2F;loaders</li><li>internal&#x2F;bootstrap&#x2F;node<ul><li>node global extensions and the process object 설정</li></ul></li><li>internal&#x2F;bootstrap&#x2F;browser<ul><li>web API global extensions 설정</li></ul></li><li>internal&#x2F;bootstrap&#x2F;switches&#x2F;{is_main_thread, is_not_main_thread}</li><li>internal&#x2F;bootstrap&#x2F;switches&#x2F;{does_own_process_state, does_not_own_process_state}</li></ul></li><li>LoadEnvironment<ul><li>internal&#x2F;main&#x2F;*<ul><li>internal&#x2F;bootstrap&#x2F;pre_execution</li></ul></li></ul></li></ol><p>SyntheticEnvironment의 경우, (1) 및 (2) 단계는 <code>node::Environment</code>의 principalrealm 와 유사하다. (2)에서 글로벌을 internal&#x2F;bootstrap&#x2F;switches로 초기화하는스크립트를 <code>node::Environment</code>의 principal realm과 Synthetic Realm에 대해분할해야 한다. (Synthetic Realm에서 특정 글로벌을 노출하지 않는 것과 같은 방식)</p><h4 id="global-설정"><a href="#global-설정" class="headerlink" title="global 설정"></a>global 설정</h4><ol><li><code>global</code>: internal&#x2F;bootstrap&#x2F;node<ul><li>setupGlobalProxy</li></ul></li><li><code>process</code>: internal&#x2F;bootstrap&#x2F;node</li><li><code>Buffer</code>: internal&#x2F;bootstrap&#x2F;node</li><li><code>Web interfaces</code>: internal&#x2F;bootstrap&#x2F;browser</li></ol><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://weizmangal.com/2022/10/28/what-is-a-realm-in-js/">https://weizmangal.com/2022/10/28/what-is-a-realm-in-js/</a></li><li><a href="https://developer.salesforce.com/blogs/2022/04/introducing-shadowrealm">https://developer.salesforce.com/blogs/2022/04/introducing-shadowrealm</a></li><li><a href="https://github.com/nodejs/node/pull/44179">https://github.com/nodejs/node/pull/44179</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-11-23-realm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Server JavaScript Runtime 기술 동향</title>
      <link>https://llnm.github.io/article/2023-11-22-javascript-runtime/</link>
      <guid>https://llnm.github.io/article/2023-11-22-javascript-runtime/</guid>
      <pubDate>Tue, 21 Nov 2023 15:13:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;브라우저 외부에서 JavaScript를 사용할 수 있는 Node.js가 등장한 이후 산업전반에서
다양하게 활용되며 De-facto 표준으로 자리잡았다. 현재는 Node.js의 결점을
보완하거나, 각 회사에 최적화 된 자체 솔루션으로 대체하는 방향</description>
        
      
      
      
      <content:encoded><![CDATA[<p>브라우저 외부에서 JavaScript를 사용할 수 있는 Node.js가 등장한 이후 산업전반에서다양하게 활용되며 De-facto 표준으로 자리잡았다. 현재는 Node.js의 결점을보완하거나, 각 회사에 최적화 된 자체 솔루션으로 대체하는 방향으로 JavaScript런타임이 파편화되고 있으며, 개발자들에게 통합된 개발 API을 제공하기 위한 각런타임 간 상호운용성에 대해 논의 중이다.</p><h2 id="신규-Server-Edge-JavaScript-Runtime의-주요-기능"><a href="#신규-Server-Edge-JavaScript-Runtime의-주요-기능" class="headerlink" title="신규 Server&#x2F;Edge JavaScript Runtime의 주요 기능"></a>신규 Server&#x2F;Edge JavaScript Runtime의 주요 기능</h2><p>신규 Runtime들은 각각 차별되는 다양한 기능을 가지고 있으며 Node.js 대비 크게보안, 성능, 모듈 복잡성 개선, 향상된 DX 제공 등을 주요 목표로 하고 있다. Deno는보안 측면에서 Node.js가 시스템 자원의 사용에 대해 어떠한 제한도 두고 있지 않는것에 비해, 사용자가 사용하는 외부 모듈에 대해서 투명하게 공지하고 제한하는기능을 제공한다.</p><p>Bun은 Network&#x2F;DB 테이블 로딩등의 성능에 있어서 유의미한 차이를 제공하며,Workerd는 여러 앱을 하나의 Runtime에서 실행하여 메모리 사용량 및 Cold Start속도를 향상시킨다. Core API에 여러 기능이 포함되는 것을 지양한 Node.js에 비해,신규 Runtime에서는 모던 JavaScript 앱 개발시 빈번하게 사용되는 필요한 기능 (예:Transpiler, Package manager, Bundler, Test Runner 기능등)을 Core 기능으로포함시켜 DX를 향상시키고 있다.</p><p>공통적인 특징은 각 Runtime의 Core API의 디자인을 Web Platform API을 기반으로하였다고, 새로운 기능을 제공하면서 많은 Eco를 확보하고 있는 Node.js Core API의호환성을 보완한다는 점이다. 그리고, Node.js 또한 이러한 신규 Runtime의 영향으로보안, 성능, DX 향상등에 점진적으로 보완해가는 중이다.</p><p><img src="https://i.imgur.com/U2uMvGh.png"></p><h3 id="Denoland-Deno-https-deno-com"><a href="#Denoland-Deno-https-deno-com" class="headerlink" title="Denoland - Deno (https://deno.com/)"></a>Denoland - Deno (<a href="https://deno.com/">https://deno.com/</a>)</h3><ul><li>V8 엔진 기반, Rust로 Core 작성, TypeScript 지원, Web Platform API 호환성 제공</li><li>FileSystem, Network, Script Execution 등에 대한 Permissions Model 제공</li><li>NPM과 같은 중앙집중형 모듈 저장소를 사용하지 않음</li></ul><h3 id="Oven-Bun-https-bun-sh"><a href="#Oven-Bun-https-bun-sh" class="headerlink" title="Oven - Bun (https://bun.sh/)"></a>Oven - Bun (<a href="https://bun.sh/">https://bun.sh/</a>)</h3><ul><li>JavaScriptCore 엔진, Zig 언어로 Core 작성, TypeScript 지원, Web Platform API호환성 제공</li><li>Cold Start 시간, Network&#x2F;DB Request 처리 시간 등 성능에 최적화</li><li>FFI(foreign function interface) 기능, 내장 SQLite3 지원</li><li>All-in-one DX 제공 (Package Manager, Bundler, Test Runner등이 Runtime에포함됨)</li></ul><h3 id="Cloudflare-Workerd-https-github-com-cloudflare-workerd"><a href="#Cloudflare-Workerd-https-github-com-cloudflare-workerd" class="headerlink" title="Cloudflare - Workerd (https://github.com/cloudflare/workerd)"></a>Cloudflare - Workerd (<a href="https://github.com/cloudflare/workerd">https://github.com/cloudflare/workerd</a>)</h3><ul><li>V8 엔진 기반, Webassembly, Web Platform API 호환성 제공 제공</li><li>V8 Isolation 기능을 이용한 샌드박싱 환경을 제공이 특징 - 하나의 Runtime에서여러개의 App을 수행할 수있는 독립적 공간을 제공</li><li>VM 또는 Container 대비 사용 Cold Start 시간, CPU 사용시간 및 사용 메모리 절감</li></ul><h3 id="그-밖의-Server-Edge-JavaScript-Runtime"><a href="#그-밖의-Server-Edge-JavaScript-Runtime" class="headerlink" title="그 밖의 Server&#x2F;Edge JavaScript Runtime"></a>그 밖의 Server&#x2F;Edge JavaScript Runtime</h3><ul><li>Alibaba Cloud - EdgeRoutine</li><li>Vercel - Edge Runtime</li><li>Fastly - Compute@Edge</li><li>Lagon - Lagon Runtime</li></ul><h2 id="JavaScript-Runtime-간-상호-운용성"><a href="#JavaScript-Runtime-간-상호-운용성" class="headerlink" title="JavaScript Runtime 간 상호 운용성"></a>JavaScript Runtime 간 상호 운용성</h2><p><img src="https://i.imgur.com/lgjrmnr.png"></p><p>Node.js로 시작된 Server&#x2F;Edge 향 Runtime이 다양한 형태로 파편화 되면서 개발자는Unified App을 개발이 어려워졌다. 이로 인해 여러 Runtime 구분없이 공통으로 사용할수 있는 API 제공에 대한 필요성이 제기되었다. 이식성 높은 코드를 작성에 대한 각서버쪽 JS Runtime의 사용자 피드백에 따르면 공통 API에 디자인에 대해 Web-first접근법이 매우 중요하다는 결과가 있었다. Web 플랫폼이란 가장 크고 중요한 API와지식에 바탕을 두면 특정 플랫폼이나 Runtime별 새로운 API나 기능을 배우지 않고보다 보편적으로 통용되는 API를 사용할 수 있다고 판단되었기 때문이다.</p><p>한편, Web Platform API가 브라우저의 특정 요구사항만을 고려해 설계되어있어브라우저가 아닌 환경에 쉽게 최적화가 어렵거나 동작이 미세하게 다른 점이 있었다.이러한 차이들이 발견됨에 따라 일관성있는 API 를 동작을 구현하기 어렵게 되었다.이러한 문제를 해결하기 위해, Node.js, Deno, Cloudflare, Vercel, Shopify등에서활동하는 엔지니어 주축으로 2022년 <a href="https://wintercg.org/">Web-interoperable Runtimes CommunityGroup</a> (WinterCG) 가 조직되었다. 브라우저를 포함한JavaScript Runtime의 구현이 어떻게 다르며 상호 운영성을 높이기 위한 부분을토론하고 WHATWG, W3C에 필요한 부분을 제안하고 있다.</p><p><img src="https://i.imgur.com/BGDnFN0.png"></p><p>현재 JavaScript 런타임 환경에서 지원을 권장하는 최소 API 집합이 제안되어 있다.WinterCG에 순응한 JavaScript를 만들시, 이러한 Web Platform API 기반으로 App을구성하면 브라우저, Server, Edge환경의 구별없이 JavaScript 런타임 간Portability를 보장받게 된다.</p><h2 id="Insight"><a href="#Insight" class="headerlink" title="Insight"></a>Insight</h2><p>Node.js의 성숙도와 생태계 규모는 여전히 큰 장점이다. 그러나, Node.js가JavaScript를 브라우저 외부로 가져온 것과 같이, 모던 웹 기술을 Server 또는 Edge기기 향 JavaScript 런타임에 이식해 생태계를 구축하려는 동향이 있다. 이러한흐름을 반영해 개발자를 지원하고 기기에 최적화된 JavaScript 런타임 제공을고려해볼 수 있을 것이다.</p>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-11-22-javascript-runtime/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>structuredClone in native</title>
      <link>https://llnm.github.io/article/2023-10-28-structure-clone-native/</link>
      <guid>https://llnm.github.io/article/2023-10-28-structure-clone-native/</guid>
      <pubDate>Fri, 27 Oct 2023 15:13:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;structuredClone은 객체를 deep copy 하는 API 이다. 만약 structuredClone 가
Node.js의 JavaScript 영역에 구현되어있다면 Native 영역으로 구현부를 이동시킬때
유의미한 성능향상이 있을 것이다. </description>
        
      
      
      
      <content:encoded><![CDATA[<p>structuredClone은 객체를 deep copy 하는 API 이다. 만약 structuredClone 가Node.js의 JavaScript 영역에 구현되어있다면 Native 영역으로 구현부를 이동시킬때유의미한 성능향상이 있을 것이다. <a href="https://github.com/nodejs/node/pull/50330">src: implementstructuredClone</a> 은 그런면에서흥미로운 내용일 것이라 생각하고 리뷰해보았다.</p><p><img src="https://i.imgur.com/O7GVcaQ.png"></p><h2 id="기존-구현"><a href="#기존-구현" class="headerlink" title="기존 구현"></a>기존 구현</h2><p>Web Platform API인 structuredClone은 원래 global 영역에 노출되어있지 않은API였다. Deep Copy를 JavaScript 에서 제공하지 않지만, Web Spec. 인<a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel">MessageChannel</a>이나 IndexedDB 같은 기능을 위해선 Object의 직렬화&#x2F;역직렬화 기능은 필요할 수 밖에없었다. 예를들어 Web Worker에서 한 Thread에서 다른 Thread로 전달하는 것은 서로다른 JavaScript Context로 데이터를 넘기는 일이기 때문에 Deep Copy 기능이필요하다.</p><p>Node.js 에는 structuredClone API 앞서<a href="https://developer.mozilla.org/en-US/docs/Web/API/MessageChannel">MessageChannel</a>이구현되어 있었는데 이를 활용한 hack 을 이용하면 structuredClone의 결과와 같은Deep Copy를 구현할 수 있었다. 그래서 기존에는 아래와 같은 방식으로 구현되었었다.</p><figure class="highlight js"><figcaption><span>structured_clone.js</span><a href="https://github.com/nodejs/node/blob/b6bced8e848c9e64964ef8d91785f4ccc7523a20/lib/internal/structured_clone.js">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">structuredClone</span>(<span class="params">value, options = <span class="literal">undefined</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_MISSING_ARGS</span>(<span class="string">&#x27;value&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Improve this with a more efficient solution that avoids</span></span><br><span class="line">  <span class="comment">// instantiating a MessageChannel</span></span><br><span class="line">  channel ??= <span class="keyword">new</span> <span class="title class_">MessageChannel</span>();</span><br><span class="line">  channel.<span class="property">port1</span>.<span class="title function_">unref</span>();</span><br><span class="line">  channel.<span class="property">port2</span>.<span class="title function_">unref</span>();</span><br><span class="line">  channel.<span class="property">port1</span>.<span class="title function_">postMessage</span>(value, options?.<span class="property">transfer</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">receiveMessageOnPort</span>(channel.<span class="property">port2</span>).<span class="property">message</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>아이디어는 MessageChannel의 인스턴스를 생성하고 해당 channel로 데이터를전달함으로서 그 과정에서 수행되는 structuredCloned 을 이용하는 것이다.</p><h3 id="MessageChannel-내부"><a href="#MessageChannel-내부" class="headerlink" title="MessageChannel 내부"></a>MessageChannel 내부</h3><p><code>MessageChannel::postMessage(value[,&#123; transfer &#125;])</code> 내부 구현에서structuredClone의 구현은 아래와 같은 두개의 Step을 통해 구현된다.</p><ul><li>Step 1. clone 하거나 transfer 해야할 객체를 리스트업 한다.</li><li>Step 2. 직렬화&#x2F;역직렬화 과정을 수행한다.</li></ul><p>기존 구현의 TODO로 기술되어있듯이 원 저자 역시 structuredClone을 위해MessageChannel을 사용하는 것이 그렇게 효율적인 방법은 아니라는 것을 기술해두었다. PR Author는 <code>MessageChannel::postMessage()</code>에서 상기 Step 1 동작을수행하는 부분을 직접 JavaScript 영역에서 호출하면 <code>MessageChannel</code>을 이용하지않을 수 있을 것이라 생각했다. 현재 코드 상에서 큰 리팩토링을 우려했지만생각보다는 적은 수고로 가능한 내용이었다.</p><ul><li>As-Is: structuredClone (JS)<ul><li>... <code>(1)</code> new <code>MessageChannel</code></li><li><code>MessageChannel::postMessage</code> (C++)<ul><li>... <code>(2)</code> MessageChannel 구현</li><li>Step 1</li><li>Step 2</li><li>... <code>(3)</code></li></ul></li></ul></li></ul><p>위는 기존 구현부를 단순화한 내용이다. PR의 아이디어는 <code>MessageChannel</code> 와 관련된 위의(1), (2), (3) 해당하는 부분을 제거한다. Step 1에 해당하는 부분을 <code>MessageChannel</code> 와공유하고 Step 2 구현을 구현하여 structuredClone의 구현체를 단순화 시키는 내용이다.</p><h4 id="Step-1"><a href="#Step-1" class="headerlink" title="Step 1"></a>Step 1</h4><p>transfer를 해야할 객체의 리스트업을 다음 함수 GetTransferList로 분리한 뒤 새로native side에서 구현한 structuredClone과 기존<code>MessageChannel::postMessage()</code>에서 공동으로 사용하도록 한다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">GetTransferList</span><span class="params">(Environment* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                     Local&lt;Context&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                     Local&lt;Value&gt; transfer_list_v,</span></span></span><br><span class="line"><span class="params"><span class="function">                     TransferList* transfer_list_out)</span> </span>&#123;</span><br><span class="line">                     ...</span><br><span class="line">                     &#125;</span><br></pre></td></tr></table></figure><h4 id="Step-2"><a href="#Step-2" class="headerlink" title="Step 2"></a>Step 2</h4><p>이후 직렬화&#x2F;역직렬화를 수행해 clone을 수행한다.</p><ul><li>To-Be: structuredClone (JS)<ul><li><code>internalBinding(&#39;messaging&#39;).structuredClone</code> (C++)<ul><li>Step 1</li><li>Step 2</li></ul></li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Local</span>&lt;<span class="title class_">Value</span>&gt; value = args[<span class="number">0</span>];</span><br><span class="line"><span class="title class_">TransferList</span> transfer_list;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 1</span></span><br><span class="line"><span class="title class_">GetTransferList</span>(env, context, transfer_list_v, &amp;transfer_list)</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">// step 2</span></span><br><span class="line"><span class="title class_">Local</span>&lt;<span class="title class_">Value</span>&gt; result;</span><br><span class="line"><span class="keyword">if</span> (msg-&gt;<span class="title class_">Serialize</span>(env, context, value, transfer_list, <span class="title class_">Local</span>&lt;<span class="title class_">Object</span>&gt;())</span><br><span class="line">        .<span class="title class_">IsNothing</span>() ||</span><br><span class="line">    !msg-&gt;<span class="title class_">Deserialize</span>(env, context, nullptr).<span class="title class_">ToLocal</span>(&amp;result)) &#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Step-3"><a href="#Step-3" class="headerlink" title="Step 3"></a>Step 3</h4><p>직렬화&#x2F;역질화 의 내부 알고리즘은 V8 내부에서 수행하며, <code>src/node_messaging.cc</code>에는 Node.js에서 정의한 객체에 대한 clonning을 어떻게 할지가 정의되어 있다.</p><h2 id="성능의-향상"><a href="#성능의-향상" class="headerlink" title="성능의 향상?"></a>성능의 향상?</h2><p>이 PR의 제목만 보면 JavaScript side에서 수행하는 Cloning을 native side로이동시키면서 상당한 성능의 향상이 있을 것이란 생각이 들었다. 그러나 실제로는<code>MessageChannel</code>의 instance 를 생성하는 부하만 줄이는 것이며 실제로 Cloning되는메카니즘은 그대로이다. 그래서 structuredClone 자체의 성능은 더 개선할 내용이 있는 것이다.</p><p><code>GetTransferList</code> 안은 <code>ReadIterable</code>이 구현되어있으며 transfer 목록을 순회하기위해 iterator를 호출한다. 이 과정에서 JavaScript Side와 Native Side간 ContextSwitching 이 일어나 속도가 저하된다. 이 부분은 여전히 TODO로 남겨졌다.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Maybe&lt;<span class="type">bool</span>&gt; <span class="title">ReadIterable</span><span class="params">(Environment* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Local&lt;Context&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                <span class="comment">// NOLINTNEXTLINE(runtime/references)</span></span></span></span><br><span class="line"><span class="params"><span class="function">                                TransferList&amp; transfer_list,</span></span></span><br><span class="line"><span class="params"><span class="function">                                Local&lt;Value&gt; object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!object-&gt;<span class="built_in">IsObject</span>()) <span class="keyword">return</span> <span class="built_in">Just</span>(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  std::vector&lt;Local&lt;Value&gt;&gt; entries;</span><br><span class="line">  <span class="keyword">while</span> (env-&gt;<span class="built_in">can_call_into_js</span>()) &#123;</span><br><span class="line">    Local&lt;Value&gt; result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 이곳의 while 문에서 C++ -&gt; JavaScript 호출이 되며 성능 저하가 일어난다.</span></span><br><span class="line">    <span class="keyword">if</span> (!next.<span class="built_in">As</span>&lt;Function&gt;()-&gt;<span class="built_in">Call</span>(context, iterator, <span class="number">0</span>, <span class="literal">nullptr</span>)</span><br><span class="line">        .<span class="built_in">ToLocal</span>(&amp;result)) <span class="keyword">return</span> <span class="built_in">Nothing</span>&lt;<span class="type">bool</span>&gt;();</span><br><span class="line"></span><br><span class="line">  transfer_list.<span class="built_in">AllocateSufficientStorage</span>(entries.<span class="built_in">size</span>());</span><br><span class="line">  std::<span class="built_in">copy</span>(entries.<span class="built_in">begin</span>(), entries.<span class="built_in">end</span>(), &amp;transfer_list[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Just</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="결과"><a href="#결과" class="headerlink" title="결과"></a>결과</h2><p>structuredClone을 위해 MessageChannel instance가 생성되는 시간을 줄이고 기존에JavaScript side에서 구현되어 snapshot에 포함되지 못했던 structuredClone 기능을snapshot에 포함할 수 있었던 것이 해당 PR의 의미라고 할 수 있다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// snapshot 생성시 포함되도록 등록</span></span><br><span class="line">registry-&gt;<span class="title class_">Register</span>(<span class="title class_">StructuredClone</span>);</span><br></pre></td></tr></table></figure><p>한가지 의문은 Web Spec.에 의하면 trasfer 는 An <em>array</em> of <code>transferable objects</code>that will be moved rather than cloned to the returned object. 이라고 정의되어있는데 왜 iterable로서 순회해야하는지는 의문이다. Array 객체로서 순회하는것은 V8 API로 존재하고 있기 때문에 iteratable interface에 따라 <code>next()</code> 호출을해주지 않아도 구현이 가능할 것 같은데 말이다. 아무튼, iterable로 처리되야한다면상기 언급했던 Step 1를 JavaScript 쪽에서 목록을 만들고 C++ 로 넘길 수 있으면 TODO로남겨진 성능 저하를 개선 할 수 있을 것이라 생각된다.</p><h2 id="관련-컨텐츠"><a href="#관련-컨텐츠" class="headerlink" title="관련 컨텐츠"></a>관련 컨텐츠</h2><ul><li><a href="../2023-10-11-iteration-protocols">Iteration protocols</a></li><li><a href="../2023-10-14-structure-clone">structureClone</a></li></ul><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://github.com/nodejs/node/pull/50330">https://github.com/nodejs/node/pull/50330</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-10-28-structure-clone-native/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>structureClone</title>
      <link>https://llnm.github.io/article/2023-10-14-structure-clone/</link>
      <guid>https://llnm.github.io/article/2023-10-14-structure-clone/</guid>
      <pubDate>Fri, 13 Oct 2023 07:43:45 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4wXgbSE.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;JavaScript에서 값을 복사할때는 항상 얕은 복사 (shallow copy)를 수행한다. 따라서
primitive data type (string, </description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://i.imgur.com/4wXgbSE.png"></p><p>JavaScript에서 값을 복사할때는 항상 얕은 복사 (shallow copy)를 수행한다. 따라서primitive data type (string, number, bigint, boolean, undefined, symbol등) 이아닌 경우 객체의 참조로 처리된다. 얕은 복사의 반대는 깊은 복사 (deep copy)인데,이는 복사 중 다른 객체를 참조를 찾으면 재귀적으로 참조의 내용도 찾아 복사를수행한다. 이렇게 참조가 있는 한 객체를 깊은 복사하는 것은 꽤 까다로운 일이다.결과물인 복사된 객체에서 원본이 가르키는 어떤 참조도 중첩하여 갖게해서는 안되기때문이다.</p><p>JavaScript에서는 이러한 깊은 복사를 수행하는 제공되지 않는다. 그래서, 오랜동안<code>JSON.stringify/parse</code> 를 이용한 일종의 트릭을 이용한 깊은 복사 방법을 제공하는라이브러리에 의존해왔다.</p><p>그러나 Web Platform에서는 IndexedDB 저장이나, WebWorker간 MessageChannel 메세지전송등의 Spec.을 구현하고자 할때 JavaScript 직렬화&#x2F;역직렬화 방법이 필요하였다.이를 구현한 것이<a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">structuredClone</a>이며,함수 내부적으로 복사를 어떻게 수행하는지는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clonealgorithm</a>이라고부르는 Spec.에 의해 정의되어있다. 모든 타입의 JavaScript 객체가 이 알고리즘에의해 처리되는 것은 아니며, JavaScript 의 Builtin Type뿐 아니라 Web Spec. 정의된일부 객체들도 복사가 가능하도록 되어있다.</p><p><img src="https://i.imgur.com/eovjF2e.png"></p><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>API의 사용 방법은 아래와 같은데, 두번째 파라미터가 정의되었을 때의 동작이 눈여겨볼만하다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">structuredClone</span>(value);</span><br><span class="line"><span class="title function_">structuredClone</span>(value, options);</span><br></pre></td></tr></table></figure><ul><li><p>첫번째 파라미터는 structured clone algorithm이 지원하는 타입의 복사본을만든다.</p></li><li><p>2번째 파라미터 optional 한 option 값인데 현재 <code>options.transfer : Array</code> 를지원한다. 이 옵션을 통해 전달되는 값은 Transferable objects의 배열이 가능하며,Transferable objects의 대표적인 타입으로는 ArrayBuffer,Readable&#x2F;WritableStream등이 있다. 복사가 아닌 transfer를 이용할 때의 장점은두가지를 들 수 있다.</p><ol><li><p>소유권의 이전 - transfer 되는 리소스를 하나의 JavaScript Context에서만사용할 수 있게 소유권을 제한할 수 있다.</p></li><li><p>성능 - transfer 객체와 환경에 따라 zero-copy operation을 이용하여 빠르게다른 context로 넘길 수 있다. 이는 특히 WebWorker와 같이 한 thread에서 다른thread로 데이터를 넘길때 유용하다.</p></li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> buffer1 = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">16</span>);</span><br><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">buffer</span>: buffer1,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = <span class="title function_">structuredClone</span>(object1, &#123; <span class="attr">transfer</span>: [buffer1] &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating an array from the original buffer throws a TypeError</span></span><br><span class="line"><span class="keyword">const</span> int32View1 = <span class="keyword">new</span> <span class="title class_">Int32Array</span>(object1.<span class="property">buffer</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;</span><br><span class="line">  <span class="attr">amanita</span>: [<span class="string">&#x27;muscaria&#x27;</span>, <span class="string">&#x27;virosa&#x27;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = <span class="title function_">structuredClone</span>(object1); <span class="comment">// cloned</span></span><br></pre></td></tr></table></figure><h2 id="참고"><a href="#참고" class="headerlink" title="참고"></a>참고</h2><ul><li><a href="https://www.proposals.es/proposals/Structured%20Clone">https://www.proposals.es/proposals/Structured%20Clone</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/structuredClone">https://developer.mozilla.org/en-US/docs/Web/API/structuredClone</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-10-14-structure-clone/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Iteration protocols</title>
      <link>https://llnm.github.io/article/2023-10-11-iteration-protocols/</link>
      <guid>https://llnm.github.io/article/2023-10-11-iteration-protocols/</guid>
      <pubDate>Tue, 10 Oct 2023 10:47:12 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;어떤 객체가 String, Array 같이 순회 (iteration) 할 수 있는 타입이 아니더라도,
JavaScript에서 순회가 가능한 (iterable) 객체로 만드는 방법이 있다. 이를
Iteration protocol 이라하며 inter</description>
        
      
      
      
      <content:encoded><![CDATA[<p>어떤 객체가 String, Array 같이 순회 (iteration) 할 수 있는 타입이 아니더라도,JavaScript에서 순회가 가능한 (iterable) 객체로 만드는 방법이 있다. 이를Iteration protocol 이라하며 interable, iterator 를 만드는 2개의 규칙(protocol)을 기술하고 있다.</p><p>iterable 규약에 순응하는 객체는 <code>for...of</code> syntax, Spread syntax, destructuringsyntax 등에서 사용이 가능해진다.</p><h2 id="1-iterable-정의"><a href="#1-iterable-정의" class="headerlink" title="1. iterable 정의"></a>1. iterable 정의</h2><p>iterable로 정의하기 위해서는 아래와 같은 내용을 객체 또는 prototype chain내객체에서 아래 내용을 구현하여야 한다.</p><ul><li><code>[Symbol.iterator] (혹은 @@iterator)</code> 란 Property로 메소드를 구현해야한다.</li><li>해당 메서드는 iterator 객체를 반환하여야 한다.</li></ul><h2 id="2-iterator-정의"><a href="#2-iterator-정의" class="headerlink" title="2. iterator 정의"></a>2. iterator 정의</h2><p>iterable 에서 <code>[Symbol.iterator]</code> 호출에 의해 반환되는 iterator 순회할 때 마다결과를 반환한다. 결과를 반환하기 위해 iterator은 아래의 프로퍼티를 구현한다.</p><ul><li><ol><li><code>next</code> 란 이름의 메소드 구현 (필수)</li></ol><ul><li><code>next</code> 메소드는 1개 혹은 0개의 파라미터를 전달 받을 수 있으며,<code>IteratorResult</code> 인터페이스를 준수하는 객체를반환한다.<ul><li>반환값이 <code>undefined</code>의 경우 <code>&#123; done: false, value: undefined&#125;</code> 와 동일</li></ul></li></ul></li><li><ol start="2"><li><code>return(value)</code>, <code>throw(exception)</code> 메소드 구현 (옵션)</li></ol><ul><li><code>return()</code> : <code>IteratorResult</code> 인터페이스를 준수하는 객체를반환한다. 이후 <code>next</code> 메소드는 더 호출되지 않는다.</li><li><code>throw()</code> <code>IteratorResult</code> 인터페이스를 준수하는 객체를반환한다. 필요한 경우 이 메소드르 호출하여 iterator에게 오류가 감지되었음을 알린다.</li></ul></li></ul><h3 id="2-1-IteratorResult-Interface"><a href="#2-1-IteratorResult-Interface" class="headerlink" title="2.1 IteratorResult Interface"></a>2.1 <code>IteratorResult</code> Interface</h3><p><img src="https://i.imgur.com/PASANQy.png" alt="IteratorResult Interface"></p><ul><li><code>done</code> : true&#x2F;false로 반복이 끝났는지를 나타낸다. 끝났으면 true로 설정</li><li><code>value</code> : 현재 반환되는 값을 설정</li></ul><h2 id="예시"><a href="#예시" class="headerlink" title="예시"></a>예시</h2><h3 id="iterable-구현-일반"><a href="#iterable-구현-일반" class="headerlink" title="iterable 구현 일반"></a>iterable 구현 일반</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> iterable = &#123;</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;, <span class="comment">// i</span></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> i &gt; <span class="number">3</span> ? &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125; : &#123; <span class="attr">value</span>: i++, <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> iterable) <span class="variable language_">console</span>.<span class="title function_">log</span>(n); <span class="comment">// 0, 1, 2, 3</span></span><br></pre></td></tr></table></figure><h3 id="iterable-의-return-구현"><a href="#iterable-의-return-구현" class="headerlink" title="iterable 의 return() 구현"></a>iterable 의 <code>return()</code> 구현</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> customIterator = &#123;</span><br><span class="line">  <span class="attr">currentIndex</span>: <span class="number">0</span>,</span><br><span class="line"></span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">currentIndex</span>++;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">currentIndex</span> &lt;= <span class="number">5</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">currentIndex</span> &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Closing the iterator.&#x27;</span>);</span><br><span class="line">    <span class="comment">// 여기서 리소스 정리 또는 마무리 작업을 수행</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> num <span class="keyword">of</span> customIterator) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">  <span class="keyword">if</span> (num === <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">// 이터레이션을 중단. 이때 return() 메서드가 호출되고 이터레이션을 종료</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Node-js-의-lib-events-js-에서-구현-실-활용-예제"><a href="#Node-js-의-lib-events-js-에서-구현-실-활용-예제" class="headerlink" title="Node.js 의 /lib/events.js 에서 구현 (실 활용 예제)"></a>Node.js 의 <code>/lib/events.js</code> 에서 구현 (실 활용 예제)</h3><p>iterator의 <code>return()</code> 함수를 정의하여 리소스를 해제하는데 사용한다.</p><figure class="highlight js"><figcaption><span>events.js</span><a href="https://github.com/nodejs/node/blob/67b1383149a31d05f74e37fcd30f8ac30d0d9301/lib/events.js">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1103</span><br><span class="line">1104</span><br><span class="line">1105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">closeHandler</span>();</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>iteration 도중 오류를 핸들링하기 위해 <code>throw(err)</code> 함수를 정의한다.</p><figure class="highlight js"><figcaption><span>events.js</span><a href="https://github.com/nodejs/node/blob/67b1383149a31d05f74e37fcd30f8ac30d0d9301/lib/events.js">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1107</span><br><span class="line">1108</span><br><span class="line">1109</span><br><span class="line">1110</span><br><span class="line">1111</span><br><span class="line">1112</span><br><span class="line">1113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>(err) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!err || !(err <span class="keyword">instanceof</span> <span class="title class_">Error</span>)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title function_">ERR_INVALID_ARG_TYPE</span>(<span class="string">&#x27;EventEmitter.AsyncIterator&#x27;</span>,</span><br><span class="line">                                   <span class="string">&#x27;Error&#x27;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">errorHandler</span>(err);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>iteration을 위한 next() 호출이 될때 <code>IteratorResult</code> 형식으로 현재 값을 반환한다.</p><figure class="highlight js"><figcaption><span>events.js</span><a href="https://github.com/nodejs/node/blob/67b1383149a31d05f74e37fcd30f8ac30d0d9301/lib/events.js">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1071</span><br><span class="line">1072</span><br><span class="line">1073</span><br><span class="line">1074</span><br><span class="line">1075</span><br><span class="line">1076</span><br><span class="line">1077</span><br><span class="line">1078</span><br><span class="line">1079</span><br><span class="line">1080</span><br><span class="line">1081</span><br><span class="line">1082</span><br><span class="line">1083</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterator = <span class="title class_">ObjectSetPrototypeOf</span>(&#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// First, we consume all unread events</span></span><br><span class="line">    <span class="keyword">if</span> (size) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = unconsumedEvents.<span class="title function_">shift</span>();</span><br><span class="line">      size--;</span><br><span class="line">      <span class="keyword">if</span> (paused &amp;&amp; size &lt; lowWatermark) &#123;</span><br><span class="line">        emitter.<span class="title function_">resume</span>();</span><br><span class="line">        paused = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">PromiseResolve</span>(<span class="title function_">createIterResult</span>(value, <span class="literal">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>next() 호출에 대해 undefined를 반환함으로써 iteration이 종료되었음을 알린다.</p><figure class="highlight js"><figcaption><span>events.js</span><a href="https://github.com/nodejs/node/blob/67b1383149a31d05f74e37fcd30f8ac30d0d9301/lib/events.js">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1094</span><br><span class="line">1095</span><br><span class="line">1096</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// If the iterator is finished, resolve to done</span></span><br><span class="line"><span class="keyword">if</span> (finished) <span class="keyword">return</span> <span class="title function_">closeHandler</span>();</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="출처"><a href="#출처" class="headerlink" title="출처"></a>출처</h2><ul><li><a href="https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iteration">https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iteration</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-10-11-iteration-protocols/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자바스크립트 컨테이너</title>
      <link>https://llnm.github.io/article/2023-09-12-js-container/</link>
      <guid>https://llnm.github.io/article/2023-09-12-js-container/</guid>
      <pubDate>Mon, 11 Sep 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;컨테이너는 응용 프로그램과 그 실행 환경을 패키징하고 격리하는 데 사용되는
기술이다. 배포되는 서비스 소프트웨어의 운영체제 수준을 가상화하고, 응용 프로그램
및 시스템 종속성을 포함한 모든 것이 포함된 독립적인 환경을 제공한다.&lt;/p&gt;
&lt;p&gt;이런</description>
        
      
      
      
      <content:encoded><![CDATA[<p>컨테이너는 응용 프로그램과 그 실행 환경을 패키징하고 격리하는 데 사용되는기술이다. 배포되는 서비스 소프트웨어의 운영체제 수준을 가상화하고, 응용 프로그램및 시스템 종속성을 포함한 모든 것이 포함된 독립적인 환경을 제공한다.</p><p>이런 리눅스 컨테이너보다는 좀 더 높은 추상화 레벨이긴 하지만 유사한 형태의격리환경은 브라우저의 JavaScript 환경이다. 그리고, 서버 소프트웨어를 위한 새로운상위 레벨 컨테이너로서 JavaScript를 이용하는 방식이 떠오르고 있다.</p><h2 id="JavaScript-컨테이너"><a href="#JavaScript-컨테이너" class="headerlink" title="JavaScript 컨테이너"></a>JavaScript 컨테이너</h2><p>JavaScript 컨테이너란 서버 소프트웨어 배포를 위한 새로운 상위 레벨 컨테이너로,리눅스 컨테이너와는 다른 영역의 문제를 해결하기 위한 것이다. 이 컨테이너는단순함, 브라우저와의 호환성, 웹어셈블리와의 연동 등의 특징을 가지고 있다.</p><h3 id="보안"><a href="#보안" class="headerlink" title="보안"></a>보안</h3><p>보안 측면에서 컨테이너는 독립된 메모리 공간을 가지고 있으며 한 컨테이너가 다른컨테이너의 메모리 공간을 직접적으로 접근하는 것은 제한된다. 이것은 브라우저의탭(Tab) 에서 제공하는 샌드박싱 (Sandboxing)을 제공하는 것과 비슷하다. 브라우저샌드박싱은 웹 애플리케이션을 샌드박스내 격리된 환경에서 실행함으로서 악의적인코드나 공격으로부터 웹 애플리케이션 및 사용자 시스템을 보호한다.</p><h4 id="메모리-격리-Memory-Isolation"><a href="#메모리-격리-Memory-Isolation" class="headerlink" title="메모리 격리 (Memory Isolation)"></a>메모리 격리 (Memory Isolation)</h4><p>모던 브라우저는 대부분 프로세스(Process) 단위로 브라우징 세션을 격리하는샌드박스 환경을 제공한다. 브라우저의 윈도우나 탭은 이렇게 별도 프로세스가할당된다. 이에 비해 JavaScript 런타임은 프로세스가 단위 아닌, JavaScript엔진에서 제공하는 보안 매커니즘을 통해 격리 환경을 제공한다. 예를 들어 V8의Isolation 기능은 JavaScript VM (Virtual Machine) 단위로 할당이 되어야하며, VM간직접적인 메모리의 접근은 불가하다.</p><p><img src="https://i.imgur.com/bx0SBht.png"></p><h4 id="권한-모델-Permission-Model"><a href="#권한-모델-Permission-Model" class="headerlink" title="권한 모델 (Permission Model)"></a>권한 모델 (Permission Model)</h4><p>기존의 JavaScript 런타임은 사용자 자원 사용에 대한 특별한 제한을 두지 않았다.실행 권한이란 것을 JavaScript 런타임에서 제어하는 복잡성 대신 사용자에게 런타임실행환경을 안전하게 하는 책임을 넘긴 것이다. 따라서, SMACK(Simplified MandatoryAccess Control Kernel) 통한 보안 통제를 하던지, Docker Container 와 같은 격리환경을 만드는 것은 사용자의 책임이었다.</p><p>JavaScript 컨테이너는 자체적으로 권한 모델을 사용하여 애플리케이션의 요청제한한다. 기본적으로 &quot;최소 권한&quot; 원칙을 따르는데, 각 구동을 위한 필요한 권한만을부여하고, 다른 권한은 차단하는 것을 기본으로 한다. 예를 들어, File System이나Network 기능을 액세스하기 위해서는 사용자의 명시적인 동의가 필요하다.</p><h3 id="성능"><a href="#성능" class="headerlink" title="성능"></a>성능</h3><p>서버리스 플랫폼 서비스들이 SaaS 의 경우 리눅스 컨테이너나 프로세스를 사용하여실행 환경을 가동한다. 이는 자체 머신에서 JavaScript 런타임을 실행하는 것보다가벼운 환경에서 코드를 실행하지 않는다. 서버리스 플랫폼은 프로세스를 확장하는방식으로 환경 구성을 준비하기 때문에 Cold Start가 발생한다. 이런 경우 JavaScript환경에서 제공하는 격리 환경을 이용하면 단일 프로세스가 여러개의 격리환경을사용할 수 있다. 즉, Cold Start로 인한 지연을 줄이는 한편, 프로세스에 추가되는메모리 리소스의 사용도 개선된다.</p><p>또한, 프로세스 기반으로 여러개의 서비스가 실행되어 있을시, 다양한 프로세스간에전환에 필요한 시간이 걸리게된다. 예를 들어 한 프로세스에 필요한 메모리를내보내고, 다른 프로세스를 위한 메모리를 로드하는 등의 컨텍스트 스위치(ContextSwitch)가 발생한다.이는 프로세스의 갯수에 비례해 오버헤드가 발생하는데,JavaScript내 격리 환경을 이용해 애플리케이션을 구성하면 프로세스간 전환에 따른오버헤드를 없앨 수 있다.</p><p><img src="https://i.imgur.com/KsDZjj0.png"></p><h2 id="단점"><a href="#단점" class="headerlink" title="단점"></a>단점</h2><p>이러한 시스템은 임의의 컴파일된 코드를 실행할 수 없으며, Javascript나 WebAssembly가 지원하는 언어로 작성되어야한다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://blog.cloudflare.com/cloud-computing-without-containers/">https://blog.cloudflare.com/cloud-computing-without-containers/</a></li><li><a href="http://runtimejs.org/jsconf/#/17">http://runtimejs.org/jsconf/#/17</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      <category domain="https://llnm.github.io/tags/node-js/">node.js</category>
      
      
      <comments>https://llnm.github.io/article/2023-09-12-js-container/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js 프로젝트 개요 1</title>
      <link>https://llnm.github.io/article/2023-09-03-nodejs-overview-1/</link>
      <guid>https://llnm.github.io/article/2023-09-03-nodejs-overview-1/</guid>
      <pubDate>Sun, 03 Sep 2023 02:34:04 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;본 문서는 그동안의 Node.js 기여 경험을 바탕으로 Node.js 프로젝트를 처음 시작하는
사람들을 위해 간략한 개요를 전달하고자 한다. 물론 프로젝트 내용은 지속적으로
변경되고 있으며 현 시점에서 유효한 내용이다. 그러나 어느 정도 견고하게</description>
        
      
      
      
      <content:encoded><![CDATA[<p>본 문서는 그동안의 Node.js 기여 경험을 바탕으로 Node.js 프로젝트를 처음 시작하는사람들을 위해 간략한 개요를 전달하고자 한다. 물론 프로젝트 내용은 지속적으로변경되고 있으며 현 시점에서 유효한 내용이다. 그러나 어느 정도 견고하게 확정되어오랫동안 통용되고 있는 내용에 대해 작성하고자 한다.</p><h2 id="Node-js-Core의-용어"><a href="#Node-js-Core의-용어" class="headerlink" title="Node.js Core의 용어"></a>Node.js Core의 용어</h2><p>Node.js 에서의 각 요소를 가르키는 용어는 여러가지로 통용이 되어왔으나 아래와 같이 공식적으로 정리되었다.</p><ul><li>Built-in(s): Node.js 는 JavaScript 부분과 C++ 부분으로 이루어져 있다. Nodecore를 이루는 기본적으로 JavaScript 코드를 Builtins 혹은 Builtin module 이라고부른다.</li><li>Bindings: Builtins 에서 사용하는 API 로서 Native 쪽에서 실행되는 부분을뜻한다. Native 코드는 C++로 이루어져 있다. C++ 코드가 직접적으로 사용자영역으로 노출되는 경우는 없으며 JavaScript 부분에서 사용자 인터페이스를 거쳐서사용된다.</li></ul><p>일반적으로 JavaScript 부분은 사용자 인터페이스를 노출하고 Bindings를 부르기 전에입력된 Arguments에 대한 Validation을 처리한다. C++ 코드내에서는 별도의Validation은 수행하지 않고 정해진 Arguments가 들어왔는지에 대해서 Assertion을수행한다.</p><ul><li>addons: Node.js 에 동적으로 링크되는 Shared library로 Node-API, NAN 를 통해 구성되고 API를 제공한다.</li></ul><p><img src="https://i.imgur.com/oWjK2NP.png"></p><h2 id="프로젝트-소스-구성"><a href="#프로젝트-소스-구성" class="headerlink" title="프로젝트 소스 구성"></a>프로젝트 소스 구성</h2><h3 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h3><ul><li><strong>lib</strong> - JavaScript builtins 에 해당하는 코드가 포함된다. <code>lib/**/*.js</code>하위의 코드이다. 모든 모듈은 외부 인터페이스 영역과 internals 영역으로 나뉜다.이러한 구분을 통하여 internal 영역의 코드가 사용자에게 노출되어 변조되는 것을방지한다. internal&#x2F;bootstrap과 internal&#x2F;main 은 Node.js 의 Builtins를Bootstrap하는 코드와 옵션별 Entry 코드를 포함하고 있다.</li></ul><h3 id="src"><a href="#src" class="headerlink" title="src"></a>src</h3><ul><li><strong>src</strong> - C++ 영역에서 구현된 <code>src/node_*.cc</code> 의 이름으로 된 bindings 코드와<code>node_api.h</code> 파일에 정의된 addons (Node-API)지원 인터페이스 코드를 제공한다.<code>node_main.cc</code>는 Node.js 의 프로그램 Entry 이며, 각 JavaScript Context 별로생성된 환경정보는 <code>env.cc</code> 의 코드에서 정의된 Environment 클래스에 의해다룬다.</li></ul><h3 id="deps"><a href="#deps" class="headerlink" title="deps"></a>deps</h3><ul><li><strong>deps</strong> - Node.js 가 사용하고 있는 외부 Dependency들을 다룬다. v8, libuv,http_parser, zlib, openssl 등이 있다. git submodule이나 subtree로 다루지 않고직접 코드를 copy하여 사용한다. 빌드를 위해 각 프로젝트의 build config를 직접부르지 않고 gyp로 구성한 build config 를 각각에 추가해 프로젝트 root의node.gyp로 부터 읽는다. dependency가 업데이트 할때 버전 정보를 별도의 header로관리하도록 되어있다. (<code>src/*_version.h</code> 파일) 이를 통해 Node.js 에서 각dependency의 정보를 확인할 수 있게 한다. 업데이트 스크립트는<code>tools/dep_updaters/update-*.sh</code> 에서 확인할 수 있다.</li></ul><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><ul><li><strong>test</strong> - Node Core에 대한 Test를 다룬다. <code>test/parallel</code> 내 테스트 코드가주로 사용되는데, 병렬로 실행되어도 서로 영향을 미치지 않은 코드를 담고 있다.이에비해 <code>test/sequential</code>은 순차적으로 실행되어야하는 테스트를 다룬다.<code>test/cctest</code>는 gtest로 구성하여 Node.js embedder를 위한 테스트 코드,<code>test/addons</code> 은 Node-API에 대한 테스트를 포함한다. <code>test/wpt</code>는 Node.js의 Web호환성 테스트를 위해 구성되어있는데, <a href="https://github.com/web-platform-tests/wpt">Web PlatformTest</a>의 특정 버전을 가져와사용한다. wpt 버전을 업데이트하기 위한 tool과 Node.js에서 WPT test harness가동작하기 위한 환경 설정을 한다.<ul><li><code>test/common</code>: 해당 폴더는 Node.js test 구성을 위한 툴을 다루고 있다. 해당툴의 사용은 선택적인것이 아니고 반드시 모든 테스트가<code>test/common/index.js</code>를 호출해줘야한다. 각 테스트를 Node.js 런타임으로 직접실행할 수도 있지만 기본적으로 Worker Thread에서 동작하도록 되어있다. 런타임실행시 특별한 CLI option이 전달되야할 때는 <code>Flags</code> 커멘트 라인을 테스트 코드첫줄에 작성하여 전달할 수 있도록 한다.</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Flags: --no-warnings --expose-gc --expose-internals</span></span><br></pre></td></tr></table></figure><h3 id="benchmark"><a href="#benchmark" class="headerlink" title="benchmark"></a>benchmark</h3><ul><li><strong>benchmark</strong> - 연산성능을 측정하기 위한 코드를 다루고 있다. <code>compare.js</code> 는비교하고자 하는 두개의 executable을 파라미터로 받으며, local build 버전과global에 설치된 특정 Node.js 버전을 전달함으로서 하나의 코드상에서 어떤 성능변화가 있는지 확인 가능하다.</li></ul><h4 id="벤치마크-수행결과-읽는-방법"><a href="#벤치마크-수행결과-읽는-방법" class="headerlink" title="벤치마크 수행결과 읽는 방법"></a>벤치마크 수행결과 읽는 방법</h4><p>벤치마크에서의 성능차이는 실제 변경 사항 자체보다 각 환경에 따라 발생하는 임의의변수들로 인해 달라질 수 있다. 그렇기 때문에 수행결과의 신뢰성 나타내는 지표를확인할 필요가 있다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">                                confidence improvement accuracy (*)   (**)  (***)</span><br><span class="line">util/priority-queue.js n=100000                -2.50 %       ±4.41% ±5.87% ±7.64%</span><br><span class="line">fs/bench-writeSync.js n=100000         ***    116.41 %       ±9.35% ±12.49% ±16.36%</span><br><span class="line">fs/bench-readSync.js n=100000 type=1            0.46 %       ±6.13%  ±8.16% ±10.62%</span><br><span class="line"></span><br><span class="line">Be aware that when doing many comparisons the risk of a false-positive</span><br><span class="line">result increases. In this case, there are 1 comparisons, you can thus</span><br><span class="line">expect the following amount of false-positive results:</span><br><span class="line">  0.05 false positives, when considering a   5% risk acceptance (*, **, ***),</span><br><span class="line">  0.01 false positives, when considering a   1% risk acceptance (**, ***),</span><br><span class="line">  0.00 false positives, when considering a 0.1% risk acceptance (***)</span><br></pre></td></tr></table></figure><p>벤치마크를 수행하면 위와 같은 결과를 확인 할 수 있다. 이때 먼저 확인해야 할 것은confidence다. confidence에 별표 (*, **, ***) 가 없는 모든 줄은 무시한다.</p><p><code>util/priority-queue.js</code> 케이스를 해석하면 -2.50%-4.41%와 -2.50%+4.41% 사이라고가정할 수 있으며, 해당 내용은 5%의 확률로 틀린 결과 (False Positives) 일 수있다는 뜻이다. Node.js 에서는 일반적으로 별표가 2개 혹은 3개 정도의 risk허용범위에 있을때 개선, 퇴보 여부를 신뢰할 수 있는 데이터라고 생각하고 있다.</p><h3 id="typings"><a href="#typings" class="headerlink" title="typings"></a>typings</h3><ul><li><strong>typings</strong> - Node.js 코드 작성시 Type을 확인할 수 있게 하는 용도로 작성된<code>*.d.ts</code> 파일을 포함한다. JavaScript 자체는 타입정보를 제공하지 않지만 이곳의파일들이 <code>lib</code> 폴더내 모듈의 외부 인터페이스 파일들과 매칭된다. vscode 와 같은툴에서 개발시 타입을 확인 할 수 있고 code complition과 같은 기능을 제공할 수있다.</li></ul><h3 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h3><ul><li><strong>doc</strong> - API 도큐먼트를 빌드하기 위한 원본 md파일과 Node.js에 기여를 할 때알아야 할 여러 정보를 확인 할 수 있다. API 도큐먼트 빌드를 목적으로 하기때문에 따라야할 convention이 존재하며 수정 후 <code>$ make format-md</code> 혹은 <code>$ tools/lint-md/lint-md.mjs</code> 이용해 lint 가능하다. API 도큐먼트의 API는 알파벳순으로 작성되야하며 내부&#x2F;외부 링크는 md에 직접 작성하지 않고 문서의 최하단에주석으로 작성되야한다. Node.js의 CLI Option이 수정되면 <code>doc/node.1</code> 의 파일을업데이트 한다. 그렇게 함으로서 Unix 계열의 운영체제에서 <code>man</code> 유틸을 통해명령어 문서에 접근할 수 있도록 한다.</li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-09-03-nodejs-overview-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js V8 Options</title>
      <link>https://llnm.github.io/article/2023-08-21-v8-options/</link>
      <guid>https://llnm.github.io/article/2023-08-21-v8-options/</guid>
      <pubDate>Mon, 21 Aug 2023 05:09:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;Node-js-V8-Build-Option&quot;&gt;&lt;a href=&quot;#Node-js-V8-Build-Option&quot; class=&quot;headerlink&quot; title=&quot;Node.js V8 Build Option&quot;&gt;&lt;/a&gt;Node.js V8 Build </description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="Node-js-V8-Build-Option"><a href="#Node-js-V8-Build-Option" class="headerlink" title="Node.js V8 Build Option"></a>Node.js V8 Build Option</h2><p><img src="https://v8.dev/_img/improved-code-caching/warm-hot-run-1.png"></p><p>Node.js는 기본적으로 JavaScript Runtime이다. JavaScript Runtime은 JavaScript를실행시킬수 있는 환경을 뜻하며 코드를 해석하고 실행하는 핵심 역할을 담당한다.Node.js 에서 여러 JavaScript 엔진중에서 구글이 개발한 V8 엔진을 사용하고 있는데,Node.js 빌드시 V8 Option을 전달하여 Customization 할 수 있다.</p><p>V8 Option은 Node.js Core코드와 직접적으로 연관이 있는 제어 코드 외 <code>deps/v8</code>에서 library 빌드 시 전달할 수 있는 옵션으로 나뉜다.</p><h3 id="Node-js-Options"><a href="#Node-js-Options" class="headerlink" title="Node.js Options"></a>Node.js Options</h3><h3 id="Lite-Mode"><a href="#Lite-Mode" class="headerlink" title="Lite Mode"></a>Lite Mode</h3><p>V8은 메모리 사용량 보다 성능 기본적으로 초점을 맞추고 있다. 그러한 개발 방향과다소 반대의 상황에서 사용할 수 있는 옵션으로 기본적인 메모리 사용량을 줄이고 JIT(Just-In-Time) 컴파일을 꺼서 메모리 소비를 더욱 줄인다.</p><p>JIT(Just-In-Time) 컴파일은 프로그램을 실행하는 동안 실제로 필요한 코드 부분만컴파일하는 기술이다. 일반적으로 JavaScript 코드는 한 줄씩 인터프리터에 의해해석되지만, JIT 컴파일러는 자주 사용되는 함수나 루프 같은 핵심 코드를 미리컴파일하고 최적화하여 실행 속도를 높인다.</p><p>관련 Configuration</p><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--v8-lite-mode&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;v8_lite_mode&#x27;</span>,</span><br><span class="line">    default=<span class="literal">False</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;compile V8 in lite mode for constrained environments (lowers V8 &#x27;</span>+</span><br><span class="line">         <span class="string">&#x27;memory footprint, but also implies no just-in-time compilation &#x27;</span> +</span><br><span class="line">         <span class="string">&#x27;support, thus much slower execution)&#x27;</span>)</span><br></pre></td></tr></table></figure><ul><li><a href="https://v8.dev/blog/v8-lite">https://v8.dev/blog/v8-lite</a></li></ul><h4 id="CodeCache-기능"><a href="#CodeCache-기능" class="headerlink" title="CodeCache 기능"></a>CodeCache 기능</h4><p>JavaScript 엔진은 CodeCache 기능을 제공한다. CodeCache는 컴파일된 코드를 캐시로저장하는 공간이며, 반복적으로 사용되는 코드를 저장해두어 빠른 실행을 가능하게한다. 이는 웹 애플리케이션의 성능을 향상시키는 데 도움이 된다.</p><p>관련 Configuration</p><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--without-node-code-cache&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;without_node_code_cache&#x27;</span>,</span><br><span class="line">    default=<span class="literal">None</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;Turn off V8 Code cache integration.&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Snapshot"><a href="#Snapshot" class="headerlink" title="Snapshot"></a>Snapshot</h4><p>Snapshot은 초기 런타임 상태를 저장하고, 이를 나중에 다시 불러와 재사용할 수 있게해준다. 이로써 애플리케이션의 시작 시간을 단축시키고 초기 로딩 시간을 최적화할수 있다.</p><p>관련 Configuration</p><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--write-snapshot-as-array-literals&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;write_snapshot_as_array_literals&#x27;</span>,</span><br><span class="line">    default=<span class="literal">None</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;Write the snapshot data as array literals for readability.&#x27;</span></span><br><span class="line">         <span class="string">&#x27;By default the snapshot data may be written as string literals on some &#x27;</span></span><br><span class="line">         <span class="string">&#x27;platforms to speed up compilation.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">parser.add_argument(<span class="string">&#x27;--without-node-snapshot&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;without_node_snapshot&#x27;</span>,</span><br><span class="line">    default=<span class="literal">None</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;Turn off V8 snapshot integration. Currently experimental.&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--v8-enable-snapshot-compression&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;v8_enable_snapshot_compression&#x27;</span>,</span><br><span class="line">    default=<span class="literal">None</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;Enable the built-in snapshot compression in V8.&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Pointer-Compression"><a href="#Pointer-Compression" class="headerlink" title="Pointer Compression"></a>Pointer Compression</h4><p>V8 엔진이 JavaScript 객체에 대한 포인터를 저장할 때 사용되는 메모리를 줄이기위한 최적화 기능이다. 기본적으로 V8는 64비트 포인터를 사용하여 객체를가리키지만, Pointer Compression을 활성화하면 객체 포인터를 더 작은 크기(32비트)의 포인터로 압축하여 메모리를 절약할 수 있다. 작은 포인터 크기는 환경에따라서 CPU 캐시에서 객체를 로드하는 데 더 효율적일 수 있으며, 이로 인해 더 빠른실행 속도를 얻을 수도 있다. 다만 이 옵션을 크면 주소공간이 4GB로 제한되며 따라서max heap 크기도 그 크기로 한정된다.</p><p>관련 Configuration</p><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--experimental-enable-pointer-compression&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store_true&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;enable_pointer_compression&#x27;</span>,</span><br><span class="line">    default=<span class="literal">None</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;[Experimental] Enable V8 pointer compression (limits max heap to 4GB and breaks ABI compatibility)&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="Runtime-V8-Options"><a href="#Runtime-V8-Options" class="headerlink" title="Runtime V8 Options"></a>Runtime V8 Options</h4><p>Node.js 실행시점에도 V8 동작에 관한 세부 설정을 할 수 있는데 이러한 옵션을 빌드시점에 default로 적용할 수 도 있다. 전체옵션을 보고싶다면 아래와 같이 실행하면된다.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node --v8-options</span><br></pre></td></tr></table></figure><p>관련 Configuration</p><figure class="highlight py"><figcaption><span>configure.py</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/configure.py">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br></pre></td><td class="code"><pre><span class="line">parser.add_argument(<span class="string">&#x27;--v8-options&#x27;</span>,</span><br><span class="line">    action=<span class="string">&#x27;store&#x27;</span>,</span><br><span class="line">    dest=<span class="string">&#x27;v8_options&#x27;</span>,</span><br><span class="line">    <span class="built_in">help</span>=<span class="string">&#x27;v8 options to pass, see `node --v8-options` for examples.&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://v8.dev/blog/improved-code-caching">https://v8.dev/blog/improved-code-caching</a></li><li><a href="https://www.geeksforgeeks.org/what-is-the-relationship-between-node-js-and-v8/">https://www.geeksforgeeks.org/what-is-the-relationship-between-node-js-and-v8/</a></li><li><a href="https://joyeecheung.github.io/blog/2022/04/14/fixing-snapshot-support-of-class-fields-in-v8/">https://joyeecheung.github.io/blog/2022/04/14/fixing-snapshot-support-of-class-fields-in-v8/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-08-21-v8-options/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>V8 Fast API에 대하여 2</title>
      <link>https://llnm.github.io/article/2023-08-14-fast-api-2/</link>
      <guid>https://llnm.github.io/article/2023-08-14-fast-api-2/</guid>
      <pubDate>Sun, 13 Aug 2023 15:30:20 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;V8-Fast-API-사용&quot;&gt;&lt;a href=&quot;#V8-Fast-API-사용&quot; class=&quot;headerlink&quot; title=&quot;V8 Fast API 사용&quot;&gt;&lt;/a&gt;V8 Fast API 사용&lt;/h2&gt;&lt;p&gt;이전 Post에 이어 본 페이지에서는 V</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="V8-Fast-API-사용"><a href="#V8-Fast-API-사용" class="headerlink" title="V8 Fast API 사용"></a>V8 Fast API 사용</h2><p>이전 Post에 이어 본 페이지에서는 V8 Fast API 를 코드 상에서 어떻게 사용하는 확인하고 어떻게 기존 API와 다른지 확인해본다.</p><img src="https://i.imgur.com/YQeC2wM.png" class=""><h3 id="1-Add-functions-for-Fast-API"><a href="#1-Add-functions-for-Fast-API" class="headerlink" title="1. Add functions for Fast API"></a>1. Add functions for Fast API</h3><p>Slow API의 경우 FunctionCallbackInfo를 인자로 받는것에 비해 Fast API는 입력값 자체를 파라미터로 받는다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">double</span> <span class="title">FastDivide</span><span class="params">(<span class="type">const</span> <span class="type">int32_t</span> a,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> <span class="type">int32_t</span> b,</span></span></span><br><span class="line"><span class="params"><span class="function">                         v8::FastApiCallbackOptions&amp; options)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">    options.fallback = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Fallback-Slow-API"><a href="#2-Fallback-Slow-API" class="headerlink" title="2. Fallback Slow API"></a>2. Fallback Slow API</h4><p>Fallback API는 사용자 지정 오류를 발생시키거나 자바스크립트 코드를 실행해야 할때와 같이 느린 경로로 전환하는 것이 바람직한 경우에 대비해 폴백을 지원한다.Fallback 메커니즘은 Fast API 함수 선언의 C++ 구현에서 활성화 및 변경할 수있는데, V8에서 FastApiCallbackOptions 을 true로 전달한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">SlowDivide</span><span class="params">(<span class="type">const</span> FunctionCallbackInfo&lt;Value&gt;&amp; args)</span> </span>&#123;</span><br><span class="line">  Environment* env = Environment::<span class="built_in">GetCurrent</span>(args);</span><br><span class="line">  <span class="built_in">CHECK_GE</span>(args.<span class="built_in">Length</span>(), <span class="number">2</span>);</span><br><span class="line">  <span class="built_in">CHECK</span>(args[<span class="number">0</span>]-&gt;<span class="built_in">IsInt32</span>());</span><br><span class="line">  <span class="built_in">CHECK</span>(args[<span class="number">1</span>]-&gt;<span class="built_in">IsInt32</span>());</span><br><span class="line">  <span class="keyword">auto</span> a = args[<span class="number">0</span>].<span class="built_in">As</span>&lt;v8::Int32&gt;();</span><br><span class="line">  <span class="keyword">auto</span> b = args[<span class="number">1</span>].<span class="built_in">As</span>&lt;v8::Int32&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (b-&gt;<span class="built_in">Value</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> node::<span class="built_in">THROW_ERR_INVALID_STATE</span>(env, <span class="string">&quot;Error&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">double</span> result = a-&gt;<span class="built_in">Value</span>() / b-&gt;<span class="built_in">Value</span>();</span><br><span class="line">  args.<span class="built_in">GetReturnValue</span>().<span class="built_in">Set</span>(v8::Number::<span class="built_in">New</span>(env-&gt;<span class="built_in">isolate</span>(), result));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>이렇게 지정된 API는 아래와 같이 JavaScript를 실행했을때 각각 Fast, Slow Path를 따라 실행하게 된다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">divide</span>(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// calls fast path</span></span><br><span class="line"><span class="title function_">divide</span>(<span class="number">2</span>, <span class="number">0</span>); <span class="comment">// calls fallback (slow path)</span></span><br></pre></td></tr></table></figure><p>기존에, <code>SetMethod</code> 나 <code>SetMethodNoSideEffect</code> 를 통해 객체에 binding API를등록했던것과 다르게 <code>SetFastMethod</code> 를 이용하여 Fast API를 등록한다. 4번째인자로 Fallback API를 전달한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">CFunction <span class="title">fast_divide_</span><span class="params">(CFunction::Make(FastDivide))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Initialize</span><span class="params">(Local&lt;Object&gt; target,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Local&lt;Value&gt; unused,</span></span></span><br><span class="line"><span class="params"><span class="function">                       Local&lt;Context&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                       <span class="type">void</span>* priv)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// SetMethodNoSideEffect(context, target, &quot;divide&quot;, SlowDivide);</span></span><br><span class="line">  <span class="built_in">SetFastMethod</span>(context, target, <span class="string">&quot;divide&quot;</span>, SlowDivide, &amp;fast_divide_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="3-Snapshot을-위한-등록"><a href="#3-Snapshot을-위한-등록" class="headerlink" title="3. Snapshot을 위한 등록"></a>3. Snapshot을 위한 등록</h3><p>어떤 API를 Snapshot으로 만들어야할지 직접 코드상에서 등록해야한다.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Snapshot</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RegisterExternalReferences</span><span class="params">(ExternalReferenceRegistry* registry)</span> </span>&#123;</span><br><span class="line">  registry-&gt;<span class="built_in">Register</span>(SlowDivide);</span><br><span class="line">  registry-&gt;<span class="built_in">Register</span>(FastDivide);</span><br><span class="line">  registry-&gt;<span class="built_in">Register</span>(fast_divide_.<span class="built_in">GetTypeInfo</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://github.com/nodejs/node/pull/46616/files#diff-81f77f34c4f5b8cc35f1a506808b94e2a281f3341c0f1a38ef2b8a8ba730b22b">buffer: use v8 fast API calls for Buffer.byteLength with sequential one-byte strings</a></li><li><a href="https://github.com/nodejs/node/pull/46579">timers: use V8 fast API calls</a></li><li><a href="https://github.com/nodejs/node/blob/main/doc/contributing/adding-v8-fast-api.md#example">adding-v8-fast-api.md</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-08-14-fast-api-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>V8 Fast API에 대하여 1</title>
      <link>https://llnm.github.io/article/2023-08-06-fast-api-1/</link>
      <guid>https://llnm.github.io/article/2023-08-06-fast-api-1/</guid>
      <pubDate>Sun, 06 Aug 2023 05:09:42 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;V8-Fast-API&quot;&gt;&lt;a href=&quot;#V8-Fast-API&quot; class=&quot;headerlink&quot; title=&quot;V8 Fast API&quot;&gt;&lt;/a&gt;V8 Fast API&lt;/h2&gt;&lt;img src=&quot;https://v8.dev/_img/v8.svg&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="V8-Fast-API"><a href="#V8-Fast-API" class="headerlink" title="V8 Fast API"></a>V8 Fast API</h2><img src="https://v8.dev/_img/v8.svg" class="" width="250"><p>V8 JavaScript 엔진은 JIT 컴파일을 수행할 수 있는 JavaScript 엔진이다. 그런데,이런 JIT에서 얻을 수 있는 최적화 장점이 C++ Binding에는 적용되기 어렵다. 그래서매번 C++ 과 JS를 오가며 변환, 설정 과정이 수반되는 Call을 불러야했다. 그로인한성능의 저하가 있었다.</p><p>JIT(Just-In-Time) 컴파일은 프로그램을 실행하는 동안 실제로 필요한 코드 부분만컴파일하는 기술이다. 일반적으로 JavaScript 코드는 한 줄씩 인터프리터에 의해해석되지만, JIT 컴파일러는 자주 사용되는 함수나 루프 같은 핵심 코드를 미리컴파일하고 최적화하여 실행 속도를 높인다.</p><p>Fast API 는 C++ 바인딩 코드에 대해서도 IR 코드로 전환될 수 있도록 지원하는기능이다. 향후 C++ 코드를 부르지 않기 때문에 빠를 수 밖에 없다. 그러나 모든 V8모든 C++ API 에 대해서 지원하는 것은 아니고 사용에 따른 제약이 존재한다.</p><h3 id="제약사항"><a href="#제약사항" class="headerlink" title="제약사항"></a>제약사항</h3><p>Fast API가 도입되었던 시기의 제약사항은 다음과 같았다. 현재에는 어떻게달라졌는지 확인해볼것이지만 아마 핵심적인 컨셉은 변경되지 않을 것이다.</p><h4 id="1-JS-Heap에-할당되서는-안된다"><a href="#1-JS-Heap에-할당되서는-안된다" class="headerlink" title="1. JS Heap에 할당되서는 안된다"></a>1. JS Heap에 할당되서는 안된다</h4><p>JS Heap은 가비지 컬렉션에 의해 관리되는데 이는 성능에 부담을 일으킬수 있는작업이고 메모리 할당 또한 마찬가지다. 성능을 향상시키기 위한 제약조건으로보여진다. 실 예로 따지면 <code>v8::Array::Get()</code> or <code>v8::Number::New()</code> 와 같은작업을 할 수 없다.</p><h4 id="2-JS-코드를-다시-호출해서는-안된다"><a href="#2-JS-코드를-다시-호출해서는-안된다" class="headerlink" title="2. JS 코드를 다시 호출해서는 안된다"></a>2. JS 코드를 다시 호출해서는 안된다</h4><p>C++ 코드가 다시 JS 코드를 호출하면 안된다. JIT 컴파일러가 생성한 최적화된 코드내에서 다시 JavaScript 코드를 호출하거나 실행하면 안 된다는 원칙을 나타낸다.예를 들어, JIT 컴파일러가 일부 코드를 최적화하고 기계 코드를 생성하였는데, 그중에 JavaScript 함수를 호출하는 부분이 있다고 가정해보자. 이렇게 되면 기계 코드내에서 JavaScript 엔진의 실행 흐름을 따라가야 하므로 최적화된 코드의 성능 향상효과가 상쇄될 수 있다. 따라서 Fast API 코드 내에서 JavaScript 코드 호출을허용하지 않고, 순수한 기계 코드로만 구성되도록 보장한다. 이렇게 함으로써최적화된 코드의 성능 개선 효과를 유지하면서 예측 가능하고 안정적인 실행을보장한다.</p><h4 id="3-에러를-Throw-하는-것도-허용되지-않는다"><a href="#3-에러를-Throw-하는-것도-허용되지-않는다" class="headerlink" title="3. 에러를 Throw 하는 것도 허용되지 않는다"></a>3. 에러를 Throw 하는 것도 허용되지 않는다</h4><p>마찬가지로 Error 처리하는데 속도문제가 있을것으로 생각된다. Fast API를 등록할때,fallback 도 등록하게 되는데, Error Throwing이 필요한 경우 fallback api (SlowAPI) 에서 작업하면 된다.</p><h4 id="4-모든-Input-type과-return-type-지원하는것이-아니다"><a href="#4-모든-Input-type과-return-type-지원하는것이-아니다" class="headerlink" title="4. 모든 Input type과 return type 지원하는것이 아니다"></a>4. 모든 Input type과 return type 지원하는것이 아니다</h4><p>현재 지원하는 코드에 대해서는 아래의 코드에서 확인할 수 있다.</p><figure class="highlight h"><figcaption><span>v8-fast-api-calls.h</span><a href="https://github.com/nodejs/node/blob/f10928f92636ee67f7b5ef3737523f428fb5ca00/deps/v8/include/v8-fast-api-calls.h">link</a></figcaption><table><tr><td class="gutter"><pre><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line">* Currently supported <span class="keyword">return</span> types:</span><br><span class="line">*   - <span class="type">void</span></span><br><span class="line">*   - <span class="type">bool</span></span><br><span class="line">*   - <span class="type">int32_t</span></span><br><span class="line">*   - <span class="type">uint32_t</span></span><br><span class="line">*   - <span class="type">float32_t</span></span><br><span class="line">*   - <span class="type">float64_t</span></span><br><span class="line">* Currently supported argument types:</span><br><span class="line">*  - pointer to an embedder type</span><br><span class="line">*  - JavaScript <span class="built_in">array</span> of primitive types</span><br><span class="line">*  - <span class="type">bool</span></span><br><span class="line">*  - <span class="type">int32_t</span></span><br><span class="line">*  - <span class="type">uint32_t</span></span><br><span class="line">*  - <span class="type">int64_t</span></span><br><span class="line">*  - <span class="type">uint64_t</span></span><br><span class="line">*  - <span class="type">float32_t</span></span><br><span class="line">*  - <span class="type">float64_t</span></span><br></pre></td></tr></table></figure><h2 id="Related-links"><a href="#Related-links" class="headerlink" title="Related links"></a>Related links</h2><ul><li><a href="https://github.com/nodejs/node/pull/46619">46619 - addSetFastMethodNoSideEffect()</a></li><li><a href="https://github.com/nodejs/node/pull/46616">46616 - buffer: use v8 fast API calls for Buffer.byteLength with sequentialone-byte strings</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-08-06-fast-api-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Split strings containing Korean and English into tokens</title>
      <link>https://llnm.github.io/article/2023-08-02-tokenize-multi-lang/</link>
      <guid>https://llnm.github.io/article/2023-08-02-tokenize-multi-lang/</guid>
      <pubDate>Tue, 01 Aug 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;blockquote&gt;
&lt;p&gt;How can we tokenize a string into a list based on language? For example, if
the string is &amp;quot;hi 안녕하세요 반가워요 hello&amp;quot;, t</description>
        
      
      
      
      <content:encoded><![CDATA[<blockquote><p>How can we tokenize a string into a list based on language? For example, ifthe string is &quot;hi 안녕하세요 반가워요 hello&quot;, the resulting list should be[&quot;hi&quot;, &quot;안녕하세요 반가워요&quot;, &quot;hello&quot;].</p></blockquote><p><img src="https://i.imgur.com/5x84agE.png"></p><p>To tokenize a string to a list by language, we can use a similar approach asbefore using regular expressions to tokenize the text based on the Unicodecharacter properties. Here&#39;s an example code snippet that tokenizes a string toa list by language using regular expressions:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># set the input string</span></span><br><span class="line">input_string = <span class="string">&#x27;hi 안녕하세요 반가워요 hello&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># detect the language of the input string</span></span><br><span class="line"><span class="keyword">if</span> re.search(<span class="string">&#x27;[\u3131-\u3163\uac00-\ud7a3]+&#x27;</span>, input_string):</span><br><span class="line">    language = <span class="string">&#x27;korean&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    language = <span class="string">&#x27;english&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># tokenize the input string using the appropriate regular expression</span></span><br><span class="line"><span class="keyword">if</span> language == <span class="string">&#x27;korean&#x27;</span>:</span><br><span class="line">    tokens = re.findall(<span class="string">&#x27;[^\s]+&#x27;</span>, input_string)</span><br><span class="line">    tokens = [re.sub(<span class="string">r&#x27;([^\w\s]|_)+&#x27;</span>, <span class="string">&#x27;&#x27;</span>, token) <span class="keyword">for</span> token <span class="keyword">in</span> tokens]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    tokens = re.findall(<span class="string">r&#x27;\w+&#x27;</span>, input_string)</span><br><span class="line"></span><br><span class="line"><span class="comment"># output the resulting list of tokens</span></span><br><span class="line"><span class="built_in">print</span>(tokens)</span><br></pre></td></tr></table></figure><p>This will output the following list of tokens: <code>[&#39;hi&#39;, &#39;안녕하세요 반가워요&#39;, &#39;hello&#39;]</code>.</p><p>Note that for Korean text, we use the regular expression <code>[^\s]+</code> to match anysequence of non-whitespace characters, which includes punctuation symbols suchas period and comma. We then use the <code>re.sub</code> function to remove any remainingpunctuation from each token.</p>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      
      <comments>https://llnm.github.io/article/2023-08-02-tokenize-multi-lang/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Mechanism over Policy</title>
      <link>https://llnm.github.io/talk/2023-07-29-mechanism-over-policy/</link>
      <guid>https://llnm.github.io/talk/2023-07-29-mechanism-over-policy/</guid>
      <pubDate>Sat, 29 Jul 2023 04:18:44 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ie22rT3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;Node.js의 dotenv 기능과 관련된 최근 Pull Request 리뷰를 진행하다 Ben Noordhuis의
견해로부터 작은 깨달음을 얻었습니다. 그</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://i.imgur.com/ie22rT3.png"></p><p>Node.js의 dotenv 기능과 관련된 최근 Pull Request 리뷰를 진행하다 Ben Noordhuis의견해로부터 작은 깨달음을 얻었습니다. 그는 해당 기능이 정책에 과도한 초점을 두면서유연성을 잃을 수 있다고 우려했습니다. 처음에는 그의 의견을 완전히 이해하기어려웠지만, 점차 고민해보면서 그의 의도를 파악할 수 있었습니다.</p><p>소프트웨어 디자인 단계에서 &quot;정책 우선 메커니즘&quot;과 &quot;메커니즘 우선 정책&quot;이라는 두가지 접근법 간의 대립을 자주 마주하게 됩니다. 전자는 정책을 먼저 결정하고 그에따라 시스템을 설계하는 방식이며, 후자는 시스템의 기본 메커니즘을 먼저 구축한다음 정책을 나중에 조정하는 방식입니다.</p><p>시스템을 개발할 때 정책을 우선 결정하면 초기부터 제한된 틀 안에서 작업해야합니다. 정책이 변경되면 시스템 전체를 다시 설계해야 할 수도 있습니다. 그러나&quot;메커니즘 우선 정책&quot;의 접근법은 더 유연한 방식을 제공합니다.</p><p>물론 모든 상황에서 메커니즘의 유연성을 우선시할 수 없지만, 소프트웨어 환경은지속적으로 변화하기 때문에 초기에 정책을 결정하고 이를 기반으로 시스템을설계하는 것이 나중에 변경하기 어려울 수 있음을 미리 인식하는 것이 중요하다는그의 의견에 공감했습니다. 앞으로 시스템을 설계할 때 항상 이를 염두에두어야겠다는 생각이 들었습니다.</p><ul><li>관련 PR: <a href="https://github.com/nodejs/node/pull/48890">https://github.com/nodejs/node/pull/48890</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/talk/">talk</category>
      
      
      
      <comments>https://llnm.github.io/talk/2023-07-29-mechanism-over-policy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Transferable 객체의 새로운 정의 방법</title>
      <link>https://llnm.github.io/article/2023-07-24-node-transferable/</link>
      <guid>https://llnm.github.io/article/2023-07-24-node-transferable/</guid>
      <pubDate>Sun, 23 Jul 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;컨텍스트-간-사용자-정의-객체-전달&quot;&gt;&lt;a href=&quot;#컨텍스트-간-사용자-정의-객체-전달&quot; class=&quot;headerlink&quot; title=&quot;컨텍스트 간 사용자 정의 객체 전달&quot;&gt;&lt;/a&gt;컨텍스트 간 사용자 정의 객체 전달&lt;/h2&gt;&lt;p&gt;Me</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="컨텍스트-간-사용자-정의-객체-전달"><a href="#컨텍스트-간-사용자-정의-객체-전달" class="headerlink" title="컨텍스트 간 사용자 정의 객체 전달"></a>컨텍스트 간 사용자 정의 객체 전달</h2><p>MessagePort는 서로 다른 컨텍스트 간에 메시지를 교환하기 위한 메커니즘입니다. V8자바스크립트 엔진은 기본 객체들의 컨텍스트 간 이동 시 직렬화와 역직렬화 방법을제공하며, 사용자 객체에 대해서도 직렬화와 역직렬화를 위한 인터페이스를제공합니다. 그러나 V8이 기존에 제공하던 이러한 인터페이스에는 문제점이 있어, Web호환성 API 등의 기능을 구현할 때 성능 저하가 발생할 수 있었습니다. 이에 대한개선을 위한 제안이 등장하여 해당 제안을 검토해보았습니다.</p><p><img src="https://blog.openreplay.com/images/deep-copying-objects-with-the-structuredclone-api/images/hero.png"></p><h3 id="기존-방법"><a href="#기존-방법" class="headerlink" title="기존 방법"></a>기존 방법</h3><h4 id="Transferable-objects"><a href="#Transferable-objects" class="headerlink" title="Transferable objects"></a>Transferable objects</h4><p>Transferable object는 한 컨텍스트에서 다른 컨텍스트로 전송 가능한 리소스를포함하는 객체입니다. 이 객체는 전송하는 컨텍스트를 벗어난 후에는 사용할 수없으며, 다른 컨텍스트에서만 활용 가능합니다. 객체를 전송한 후에는 해당컨텍스트에서 더 이상 사용할 수 없으며, 전송된 객체를 사용하려고 시도하면 에러가발생합니다. 예를 들어, ArrayBuffer를 전송하는 경우 내부 버퍼가 분리되어전송되며, 이후에 해당 버퍼에 접근하려고 하면 에러가 발생할 수 있습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = <span class="keyword">new</span> <span class="title class_">ArrayBuffer</span>(<span class="number">1</span>);</span><br><span class="line">worker.<span class="title function_">postMessage</span>(ab, [ab]);</span><br><span class="line"><span class="keyword">if</span> (ab.<span class="property">byteLength</span> == <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// ab is transferred.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>예: ArrayBuffer, MessagePort, ReadableStream, WritableStream, TransformStream,and so on.</p><h4 id="HTML-Structured-clone-algorithm"><a href="#HTML-Structured-clone-algorithm" class="headerlink" title="HTML Structured clone algorithm"></a>HTML Structured clone algorithm</h4><p>postMessage() 함수 내부에서 객체를 전송할 때에는 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm">structured clonealgorithm</a>를이 호출됩니다. 이 알고리즘이 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Structured_clone_algorithm#javascript_types">지원하는객체</a>는일반 반 객체로 한정하여 처리하며, 사용자가 별도로 정의한 Class와 같은 객체는전송이 지원되지 않습니다.</p><h4 id="Transferable-in-Node-js"><a href="#Transferable-in-Node-js" class="headerlink" title="Transferable in Node.js"></a>Transferable in Node.js</h4><p>이 알고리즘을 따라 일관된 형식으로 객체를 전송 가능하도록 만들기 위해서는 사용자정의 객체를 Host Object로 취급되게 해야 합니다. 객체가 Host Object로 인식되면 V8엔진은 사용자가 제공한 Serialize&#x2F;Deserialize 대리자를 호출합니다.</p><p>문제는 Native 계층에서는 객체를 Host Object로 인식시키는 것이 가능하지만,JavaScript 계층에서는 이를 수행할 방법이 없었습니다. 이에 따라, Native 층에서JSTransferable 클래스를 생성하고 이를 JavaScript 객체 프로토타입 체인의 상위에등록하여 Host Object로 인식되도록 했습니다. 그리고 해당 클래스에 Private Symbol([kTransfer], [kClone], [kDeserialize])을 이용한 함수를 구현하여 Serialize 및Deserialize 작업이 해당 클래스의 대리자로 호출되도록 구현했습니다.</p><p>또 다른 문제는 WritableStream 및 ReadableStream과 같은 Web API가 표준에서 다른클래스를 상속하도록 정의되어 있지 않아, JSTransferable로 이러한 클래스를 확장할수 없었습니다. 이를 해결하기 위해 makeTransferable이라는 일종의 해킹 함수를사용하여 상속 관계를 조작했습니다. 이 방식은 표준을 올바르게 구현하는 방법이긴하지만, 인스턴스가 생성될 때마다 makeTransferable 함수가 호출되기 때문에 성능측면에서는 좋지 않을 수 있었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makeTransferable</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="comment">// If the object is already transferable, skip all this.</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="title class_">JSTransferable</span>) <span class="keyword">return</span> obj;</span><br><span class="line">  <span class="keyword">const</span> inst = <span class="title class_">ReflectConstruct</span>(<span class="title class_">JSTransferable</span>, [], obj.<span class="property">constructor</span>);</span><br><span class="line">  <span class="keyword">const</span> properties = <span class="title class_">ObjectGetOwnPropertyDescriptors</span>(obj);</span><br><span class="line">  <span class="keyword">const</span> propertiesValues = <span class="title class_">ObjectValues</span>(properties);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; propertiesValues.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// We want to use null-prototype objects to not rely on globally mutable</span></span><br><span class="line">    <span class="comment">// %Object.prototype%.</span></span><br><span class="line">    <span class="title class_">ObjectSetPrototypeOf</span>(propertiesValues[i], <span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title class_">ObjectDefineProperties</span>(inst, properties);</span><br><span class="line">  <span class="title class_">ObjectSetPrototypeOf</span>(inst, <span class="title class_">ObjectGetPrototypeOf</span>(obj));</span><br><span class="line">  <span class="keyword">return</span> inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="새로운-방법"><a href="#새로운-방법" class="headerlink" title="새로운 방법"></a>새로운 방법</h3><h4 id="markTransferMode"><a href="#markTransferMode" class="headerlink" title="markTransferMode"></a><code>markTransferMode</code></h4><p>앞에서 언급한 성능 문제를 개선하기 위해 <a href="https://github.com/nodejs/node/pull/47956">새로운패치</a>가 적용되었습니다. JavaScript객체에 대해서도 Host Object로 인식할 수 있도록 하기 위해transfer_mode_private_symbol을 이용하는 방법이 도입되었습니다. 또한, V8 엔진에서기존에 Host Object를 판단하는 방식으로 EmbedderFieldCount를 확인하던 것을명시적으로 판단할 수 있도록 하기 위해 IsHostObject() 인터페이스가추가되었습니다.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// node/lib/internal/worker/js_transferable.js</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mark an object as being transferable or customized cloneable in</span></span><br><span class="line"><span class="comment"> * `.postMessage()`.</span></span><br><span class="line"><span class="comment"> * This should only applied to host objects like Web API interfaces, Node.js&#x27;</span></span><br><span class="line"><span class="comment"> * built-in objects.</span></span><br><span class="line"><span class="comment"> * Objects marked as cloneable and transferable should implement the method</span></span><br><span class="line"><span class="comment"> * `@<span class="doctag">@kClone</span>` and `@<span class="doctag">@kTransfer</span>` respectively. Method `@<span class="doctag">@kDeserialize</span>` is</span></span><br><span class="line"><span class="comment"> * required to deserialize the data to a new instance.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example implementation of a cloneable interface (assuming its located in</span></span><br><span class="line"><span class="comment"> * `internal/my_interface.js`):</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ```</span></span><br><span class="line"><span class="comment"> * class MyInterface &#123;</span></span><br><span class="line"><span class="comment"> *   constructor(...args) &#123;</span></span><br><span class="line"><span class="comment"> *     markTransferMode(this, true); // &lt;--</span></span><br><span class="line"><span class="comment"> *     this.args = args;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   [kDeserialize](data) &#123;</span></span><br><span class="line"><span class="comment"> *     this.args = data.args;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> *   [kClone]() &#123;</span></span><br><span class="line"><span class="comment"> *     return &#123;</span></span><br><span class="line"><span class="comment"> *        data: &#123; args: this.args &#125;,</span></span><br><span class="line"><span class="comment"> *        deserializeInfo: &#x27;internal/my_interface:MyInterface&#x27;,</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> *   &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * module.exports = &#123;</span></span><br><span class="line"><span class="comment"> *   MyInterface,</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> * ```</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">object</span>&#125; obj Host objects that can be either cloned or transferred.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; [cloneable] if the object can be cloned and `@<span class="doctag">@kClone</span>` is</span></span><br><span class="line"><span class="comment"> *                              implemented.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">boolean</span>&#125; [transferable] if the object can be transferred and</span></span><br><span class="line"><span class="comment"> *                                 `@<span class="doctag">@kTransfer</span>` is implemented.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">markTransferMode</span>(<span class="params">obj, cloneable = <span class="literal">false</span>, transferable = <span class="literal">false</span></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> obj !== <span class="string">&#x27;function&#x27;</span>) || obj === <span class="literal">null</span>)</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// This object is a primitive and therefore already untransferable.</span></span><br><span class="line">  <span class="keyword">let</span> mode = kDisallowCloneAndTransfer;</span><br><span class="line">  <span class="keyword">if</span> (cloneable) mode |= kCloneable;</span><br><span class="line">  <span class="keyword">if</span> (transferable) mode |= kTransferable;</span><br><span class="line">  obj[transfer_mode_private_symbol] = mode; <span class="comment">// &lt;--</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/node_messaging.cc</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// static</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">JSTransferable::IsJSTransferable</span><span class="params">(Environment* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      v8::Local&lt;v8::Context&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                                      v8::Local&lt;v8::Object&gt; object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> object-&gt;<span class="built_in">HasPrivate</span>(context, env-&gt;<span class="built_in">transfer_mode_private_symbol</span>()) <span class="comment">// &lt;--</span></span><br><span class="line">      .<span class="built_in">ToChecked</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Provide a wrapper class created when a built-in JS classes that being</span></span><br><span class="line"><span class="comment">// transferable or cloneable by postMessage().</span></span><br><span class="line"><span class="comment">// See e.g. FileHandle in internal/fs/promises.js for an example.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JSTransferable</span> : <span class="keyword">public</span> BaseObject &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="type">static</span> JSTransferable* <span class="title">Wrap</span><span class="params">(Environment* env, v8::Local&lt;v8::Object&gt; target)</span></span>;</span><br><span class="line">  <span class="function"><span class="type">static</span> <span class="type">bool</span> <span class="title">IsJSTransferable</span><span class="params">(Environment* env,</span></span></span><br><span class="line"><span class="params"><span class="function">                               v8::Local&lt;v8::Context&gt; context,</span></span></span><br><span class="line"><span class="params"><span class="function">                               v8::Local&lt;v8::Object&gt; object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This tells V8 how to serialize objects that it does not understand</span></span><br><span class="line"><span class="comment">// (e.g. C++ objects) into the output buffer, in a way that our own</span></span><br><span class="line"><span class="comment">// DeserializerDelegate understands how to unpack.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SerializerDelegate</span> : <span class="keyword">public</span> ValueSerializer::Delegate &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">HasCustomHostObject</span><span class="params">(Isolate* isolate)</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Maybe&lt;<span class="type">bool</span>&gt; <span class="title">IsHostObject</span><span class="params">(Isolate* isolate, Local&lt;Object&gt; object)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BaseObject::<span class="built_in">IsBaseObject</span>(object)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Just</span>(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Just</span>(JSTransferable::<span class="built_in">IsJSTransferable</span>(env_, context_, object)); <span class="comment">// &lt;--</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Maybe&lt;<span class="type">bool</span>&gt; <span class="title">WriteHostObject</span><span class="params">(Isolate* isolate, Local&lt;Object&gt; object)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BaseObject::<span class="built_in">IsBaseObject</span>(object)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">WriteHostObject</span>(</span><br><span class="line">          BaseObjectPtr&lt;BaseObject&gt; &#123; <span class="built_in">Unwrap</span>&lt;BaseObject&gt;(object) &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (JSTransferable::<span class="built_in">IsJSTransferable</span>(env_, context_, object)) &#123;</span><br><span class="line">      JSTransferable* js_transferable = JSTransferable::<span class="built_in">Wrap</span>(env_, object);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">WriteHostObject</span>(BaseObjectPtr&lt;BaseObject&gt;&#123;js_transferable&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// This is used to tell V8 how to read transferred host objects, like other</span></span><br><span class="line"><span class="comment">// `MessagePort`s and `SharedArrayBuffer`s, and make new JS objects out of them.</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DeserializerDelegate</span> : <span class="keyword">public</span> ValueDeserializer::Delegate &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="function">MaybeLocal&lt;Object&gt; <span class="title">ReadHostObject</span><span class="params">(Isolate* isolate)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Identifying the index in the message&#x27;s BaseObject array is sufficient.</span></span><br><span class="line">    <span class="type">uint32_t</span> id;</span><br><span class="line">    <span class="keyword">if</span> (!deserializer-&gt;<span class="built_in">ReadUint32</span>(&amp;id))</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">MaybeLocal</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (id != kNormalObject) &#123;</span><br><span class="line">      <span class="built_in">CHECK_LT</span>(id, host_objects_.<span class="built_in">size</span>());</span><br><span class="line">      Local&lt;Object&gt; object = host_objects_[id]-&gt;<span class="built_in">object</span>(isolate);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (env_-&gt;<span class="built_in">js_transferable_constructor_template</span>()-&gt;<span class="built_in">HasInstance</span>(object)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Unwrap</span>&lt;JSTransferable&gt;(object)-&gt;<span class="built_in">target</span>();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="V8"><a href="#V8" class="headerlink" title="V8"></a>V8</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// deps/v8/include/v8-value-serializer.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Value serialization compatible with the HTML structured clone algorithm.</span></span><br><span class="line"><span class="comment"> * The format is backward-compatible (i.e. safe to store to disk).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">V8_EXPORT</span> ValueSerializer &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The embedder overrides this method to enable custom host object filter</span></span><br><span class="line"><span class="comment">   * with Delegate::IsHostObject.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * This method is called at most once per serializer.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="type">bool</span> <span class="title">HasCustomHostObject</span><span class="params">(Isolate* isolate)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * The embedder overrides this method to determine if an JS object is a</span></span><br><span class="line"><span class="comment">   * host object and needs to be serialized by the host.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Maybe&lt;<span class="type">bool</span>&gt; <span class="title">IsHostObject</span><span class="params">(Isolate* isolate, Local&lt;Object&gt; object)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deps/v8/src/api/api.cc</span></span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> ValueSerializer::Delegate::<span class="built_in">HasCustomHostObject</span>(Isolate* v8_isolate) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe&lt;<span class="type">bool</span>&gt; ValueSerializer::Delegate::<span class="built_in">IsHostObject</span>(Isolate* v8_isolate,</span><br><span class="line">                                                    Local&lt;Object&gt; object) &#123;</span><br><span class="line">  i::Isolate* i_isolate = <span class="built_in">reinterpret_cast</span>&lt;i::Isolate*&gt;(v8_isolate);</span><br><span class="line">  i::Handle&lt;i::JSObject&gt; js_object =</span><br><span class="line">      i::Handle&lt;i::JSObject&gt;::<span class="built_in">cast</span>(Utils::<span class="built_in">OpenHandle</span>(*object));</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Just</span>&lt;<span class="type">bool</span>&gt;(</span><br><span class="line">      i::JSObject::<span class="built_in">GetEmbedderFieldCount</span>(js_object-&gt;<span class="built_in">map</span>(i_isolate)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// deps/v8/src/objects/value-serializer.cc</span></span><br><span class="line"></span><br><span class="line">ValueSerializer::<span class="built_in">ValueSerializer</span>(Isolate* isolate,</span><br><span class="line">                                 v8::ValueSerializer::Delegate* delegate)</span><br><span class="line">    : <span class="built_in">isolate_</span>(isolate),</span><br><span class="line">      <span class="built_in">delegate_</span>(delegate),</span><br><span class="line">      <span class="built_in">zone_</span>(isolate-&gt;<span class="built_in">allocator</span>(), ZONE_NAME),</span><br><span class="line">      <span class="built_in">id_map_</span>(isolate-&gt;<span class="built_in">heap</span>(), <span class="built_in">ZoneAllocationPolicy</span>(&amp;zone_)),</span><br><span class="line">      <span class="built_in">array_buffer_transfer_map_</span>(isolate-&gt;<span class="built_in">heap</span>(),</span><br><span class="line">                                 <span class="built_in">ZoneAllocationPolicy</span>(&amp;zone_)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (delegate_) &#123;</span><br><span class="line">    v8::Isolate* v8_isolate = <span class="built_in">reinterpret_cast</span>&lt;v8::Isolate*&gt;(isolate_);</span><br><span class="line">    has_custom_host_objects_ = delegate_-&gt;<span class="built_in">HasCustomHostObject</span>(v8_isolate);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 이전에 Host Object를 구별하는 방법이 EmbedderFieldCount를 확인하는 방법이었다면</span></span><br><span class="line"><span class="comment">// 명시적으로 이를 확인하는 방법을 추가하였다.</span></span><br><span class="line"></span><br><span class="line"><span class="function">Maybe&lt;<span class="type">bool</span>&gt; <span class="title">ValueSerializer::WriteJSReceiver</span><span class="params">(Handle&lt;JSReceiver&gt; receiver)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="function">HandleScope <span class="title">scope</span><span class="params">(isolate_)</span></span>;</span><br><span class="line">  <span class="keyword">switch</span> (instance_type) &#123;</span><br><span class="line">    <span class="keyword">case</span> JS_ARRAY_TYPE:</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">WriteJSArray</span>(Handle&lt;JSArray&gt;::<span class="built_in">cast</span>(receiver));</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> JS_API_OBJECT_TYPE: &#123;</span><br><span class="line">      Handle&lt;JSObject&gt; js_object = Handle&lt;JSObject&gt;::<span class="built_in">cast</span>(receiver);</span><br><span class="line">      <span class="comment">// if (JSObject::GetEmbedderFieldCount(js_object-&gt;map(isolate_))) &#123; // -</span></span><br><span class="line">      Maybe&lt;<span class="type">bool</span>&gt; is_host_object = <span class="built_in">IsHostObject</span>(js_object);               <span class="comment">// +</span></span><br><span class="line">      <span class="keyword">if</span> (is_host_object.<span class="built_in">IsNothing</span>()) &#123;                                   <span class="comment">// +</span></span><br><span class="line">        <span class="keyword">return</span> is_host_object;                                            <span class="comment">// +</span></span><br><span class="line">      &#125;                                                                   <span class="comment">// +</span></span><br><span class="line">      <span class="keyword">if</span> (is_host_object.<span class="built_in">FromJust</span>()) &#123;                                    <span class="comment">// +</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WriteHostObject</span>(js_object);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">WriteJSObject</span>(js_object);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Maybe&lt;<span class="type">bool</span>&gt; <span class="title">ValueSerializer::IsHostObject</span><span class="params">(Handle&lt;JSObject&gt; js_object)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!has_custom_host_objects_) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Just</span>&lt;<span class="type">bool</span>&gt;(</span><br><span class="line">        JSObject::<span class="built_in">GetEmbedderFieldCount</span>(js_object-&gt;<span class="built_in">map</span>(isolate_)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">DCHECK_NOT_NULL</span>(delegate_);</span><br><span class="line"></span><br><span class="line">  v8::Isolate* v8_isolate = <span class="built_in">reinterpret_cast</span>&lt;v8::Isolate*&gt;(isolate_);</span><br><span class="line"></span><br><span class="line">  Maybe&lt;<span class="type">bool</span>&gt; result =</span><br><span class="line">      delegate_-&gt;<span class="built_in">IsHostObject</span>(v8_isolate, Utils::<span class="built_in">ToLocal</span>(js_object)); <span class="comment">// &lt;--</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">RETURN_VALUE_IF_SCHEDULED_EXCEPTION</span>(isolate_, <span class="built_in">Nothing</span>&lt;<span class="type">bool</span>&gt;());</span><br><span class="line">  <span class="built_in">DCHECK</span>(!result.<span class="built_in">IsNothing</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">V8_UNLIKELY</span>(out_of_memory_)) <span class="keyword">return</span> <span class="built_in">ThrowIfOutOfMemory</span>();</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="References"><a href="#References" class="headerlink" title="References"></a>References</h3><ul><li><a href="https://github.com/nodejs/node/pull/47956">make JSTransferables based on privatesymbols</a></li><li><a href="https://github.com/nodejs/node/issues/37080">Userland transferable&#x2F;cloneableobjects</a></li><li><a href="https://github.com/nodejs/undici/issues/1203#issuecomment-1101482629">makeTransferable</a></li><li><a href="https://github.com/nodejs/performance/issues/82#issuecomment-1613378037">https://github.com/nodejs/performance/issues/82#issuecomment-1613378037</a></li><li><a href="https://developer.chrome.com/blog/transferable-objects-lightning-fast/">https://developer.chrome.com/blog/transferable-objects-lightning-fast/</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      <category domain="https://llnm.github.io/tags/node-js/">node.js</category>
      
      
      <comments>https://llnm.github.io/article/2023-07-24-node-transferable/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Automated semantic versioning based on commits.</title>
      <link>https://llnm.github.io/article/2023-07-16-automated-semver/</link>
      <guid>https://llnm.github.io/article/2023-07-16-automated-semver/</guid>
      <pubDate>Sat, 15 Jul 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;I wondered if there was a way to automatically update the patch version of
&lt;a href=&quot;https://semver.org/&quot;&gt;SemVer&lt;/a&gt; when a commit is made</description>
        
      
      
      
      <content:encoded><![CDATA[<p>I wondered if there was a way to automatically update the patch version of<a href="https://semver.org/">SemVer</a> when a commit is made. I tried to make it usingthe commit hook in python.</p><p><img src="https://charly3pins.dev/images/semver.png"></p><ol><li>Create a <code>version.py</code> file with a variable to store the version:</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># version.py</span></span><br><span class="line">__version__ = <span class="string">&#x27;0.1.0&#x27;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>Add a pre-commit hook script that updates the version in the <code>version.py</code>file:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .git/hooks/pre-commit</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Get the current version from version.py</span></span><br><span class="line">VERSION=$(sed -nE <span class="string">&#x27;s/^__version__ = (\x27|\&quot;)(.*)\1$/\2/p&#x27;</span> version.py)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Increment the patch number</span></span><br><span class="line">PATCH=$(<span class="built_in">echo</span> <span class="variable">$VERSION</span> | awk -F. <span class="string">&#x27;&#123;print $3&#125;&#x27;</span>)</span><br><span class="line">NEW_PATCH=$(<span class="built_in">expr</span> <span class="variable">$PATCH</span> + 1)</span><br><span class="line">NEW_VERSION=$(<span class="built_in">echo</span> <span class="variable">$VERSION</span> | awk -F. -v new_patch=<span class="string">&quot;<span class="variable">$NEW_PATCH</span>&quot;</span> <span class="string">&#x27;&#123;$3=new_patch; OFS=&quot;.&quot;; print $1,$2,$3&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Update the version in version.py</span></span><br><span class="line">sed -i <span class="string">&#x27;&#x27;</span> -E <span class="string">&quot;s/^__version__ = (\x27|\&quot;).*(\x27|\&quot;)/__version__ = \&#x27;<span class="variable">$NEW_VERSION</span>\&#x27;/&quot;</span> version.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stage the updated version.py file for commit</span></span><br><span class="line">git add version.py</span><br></pre></td></tr></table></figure><p>This script gets the current version number from the <code>version.py</code> file,increments the patch number, updates the version in <code>version.py</code>, and stages thefile for commit.</p><ol start="3"><li>Make the pre-commit hook script executable:</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x .git/hooks/pre-commit</span><br></pre></td></tr></table></figure><p>Now, when you make a commit, the pre-commit hook script will automaticallyupdate the version in <code>version.py</code>. You can use the <code>__version__</code> variable inyour Python code to refer to the current version number. For example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"><span class="keyword">import</span> version</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;MyApp version &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(version.__version__))</span><br></pre></td></tr></table></figure><p>This will output <code>MyApp version 0.1.1</code> if the latest commit incremented thepatch number.</p>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      <category domain="https://llnm.github.io/tags/python/">python</category>
      
      
      <comments>https://llnm.github.io/article/2023-07-16-automated-semver/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Linux I/O 성능 혁신 - io_uring</title>
      <link>https://llnm.github.io/article/2023-07-14-io-uring/</link>
      <guid>https://llnm.github.io/article/2023-07-14-io-uring/</guid>
      <pubDate>Thu, 13 Jul 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;2019년에 소개된 io_uring은 Linux 커널을 위한 비동기 I&amp;#x2F;O 인터페이스입니다. 기존
인터페이스인 epoll&amp;#x2F;kqueue와 aio 대비하여 뛰어난 성능과 간결하고 직관적인 API
사용성을 제공합니다. io_uring</description>
        
      
      
      
      <content:encoded><![CDATA[<p>2019년에 소개된 io_uring은 Linux 커널을 위한 비동기 I&#x2F;O 인터페이스입니다. 기존인터페이스인 epoll&#x2F;kqueue와 aio 대비하여 뛰어난 성능과 간결하고 직관적인 API사용성을 제공합니다. io_uring은 비동기 I&#x2F;O, 시스템 콜의 다중 배치 처리, 유연한버퍼 관리 등을 통해 Linux I&#x2F;O 모델의 중요한 발전 중 하나로 인정받고 있습니다.</p><h2 id="주요-특징"><a href="#주요-특징" class="headerlink" title="주요 특징"></a>주요 특징</h2><h3 id="동작-원리"><a href="#동작-원리" class="headerlink" title="동작 원리"></a>동작 원리</h3><p>io_uring은 사용자와 커널 간의 공유 메모리 내에 원형 큐 (queue rings)를활용합니다. 제출큐 (Submission Queue)와 완료큐 (Completion Queue)로 구성된이러한 큐를 통해 사용자는 여러 개의 I&#x2F;O 작업을 스케줄링할 수 있습니다. 커널은스케줄된 작업을 처리하고 그 결과를 완료큐에 반환하여 사용자가 결과를 처리할 수있도록 합니다.</p><p><img src="https://developers.redhat.com/sites/default/files/uring_0.png"></p><h3 id="우수한-성능"><a href="#우수한-성능" class="headerlink" title="우수한 성능"></a>우수한 성능</h3><p>io_uring은 사용자와 커널 간의 공유 메모리를 이용하여 Zero-Copy I&#x2F;O를 지원합니다.또한 사용자가 I&#x2F;O 작업을 스케줄링할 때 필요한 모든 정보를 커널에 전달하고 커널내에서 작업 완료를 관리함으로써 추가적인 사용자&#x2F;커널 간 컨텍스트 스위칭(contextswitching)을 최소화합니다. 이로써 전통적인 동기 I&#x2F;O에 비해 더 낮은 오버헤드를가지게 됩니다.</p><h3 id="간결한-인터페이스"><a href="#간결한-인터페이스" class="headerlink" title="간결한 인터페이스"></a>간결한 인터페이스</h3><p>기존의 epoll에서는 여러 개의 입출력 작업(multiplexing)을 위해 파일 디스크립터의상태를 필터링해야 했습니다. 반면 io_uring은 더 간결한 사용 방식을 제공합니다.사용자는 io_uring_enter() 함수를 호출하여 시스템 콜을 커널에 스케줄링하고 결과를처리합니다. 이러한 방식은 Polling과 Interrupt-driven I&#x2F;O를 모두 지원합니다.</p><h4 id="epoll을-사용한-설정"><a href="#epoll을-사용한-설정" class="headerlink" title="epoll을 사용한 설정"></a>epoll을 사용한 설정</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> epoll_fd = <span class="built_in">epoll_create1</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> event;</span><br><span class="line">event.events = EPOLLIN;  <span class="comment">// 읽기 이벤트 설정</span></span><br><span class="line">event.data.fd = sockfd;  <span class="comment">// 관심 있는 파일 디스크립터 설정</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">epoll_ctl</span>(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">epoll_event</span> events[MAX_EVENTS];</span><br><span class="line"><span class="type">int</span> ready_fds = <span class="built_in">epoll_wait</span>(epoll_fd, events, MAX_EVENTS, timeout);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ready_fds; i++) &#123;</span><br><span class="line">    <span class="type">int</span> fd = events[i].data.fd;</span><br><span class="line">    <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">        <span class="comment">// 읽기 이벤트 처리</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="io-uring을-사용한-설정"><a href="#io-uring을-사용한-설정" class="headerlink" title="io_uring을 사용한 설정"></a>io_uring을 사용한 설정</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;liburing.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring</span> ring;</span><br><span class="line"><span class="built_in">io_uring_queue_init</span>(QUEUE_DEPTH, &amp;ring, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_sqe</span> *sqe = <span class="built_in">io_uring_get_sqe</span>(&amp;ring);</span><br><span class="line"><span class="built_in">io_uring_prep_read</span>(sqe, sockfd, buf, buflen, offset);</span><br><span class="line"><span class="built_in">io_uring_submit</span>(&amp;ring);</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">io_uring_cqe</span> *cqe;</span><br><span class="line"><span class="type">int</span> ret = <span class="built_in">io_uring_wait_cqe</span>(&amp;ring, &amp;cqe);</span><br><span class="line"><span class="keyword">if</span> (ret &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (cqe-&gt;res &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 성공</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 에러</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">io_uring_cqe_seen</span>(&amp;ring, cqe);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="생각"><a href="#생각" class="headerlink" title="생각"></a>생각</h2><p><a href="https://github.com/libuv/libuv/pull/3952">libuv에서도 io uring API</a>를 사용할 수있게 되었습니다. 현재는 파일 연산에 한정되어 있지만, io_uring을 지원하는 커널의경우 파일 연산 처리량이 최대 8배까지 증가하는 것으로 확인되었습니다. 파일 연산이많거나 파일과 네트워크 I&#x2F;O 워크로드가 혼합된 시스템에서는 io_uring의 사용으로비약적인 성능 향상이 가능할 것으로 보입니다. 이러한 잠재력을 고려하여 io_uring을활용하는 것이 유용할 것입니다.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://github.com/nodejs/node/pull/48618">deps: upgrade to libuv 1.46.0</a></li><li><a href="https://github.com/libuv/libuv/issues/1947">New kernel polling interface for Linux 4.18(io_uring)?</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      <category domain="https://llnm.github.io/tags/node-js/">node.js</category>
      
      
      <comments>https://llnm.github.io/article/2023-07-14-io-uring/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Node.js 활용 사례 - Netflix</title>
      <link>https://llnm.github.io/article/2023-07-07-nodejs-usecase-netflix/</link>
      <guid>https://llnm.github.io/article/2023-07-07-nodejs-usecase-netflix/</guid>
      <pubDate>Fri, 07 Jul 2023 01:31:10 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;2009년 Node.js가 등장한 이래 Node.js는 현대 소프트웨어 개발에서 매우 중요한
역할을 하고 있습니다. 그러한 역할은 산업 전반의 다양한 활용 사례를 통해 입증되고
있습니다. 이 글은 그 활용 사례중 한 도입 사례를 한 발 더 깊이 </description>
        
      
      
      
      <content:encoded><![CDATA[<p>2009년 Node.js가 등장한 이래 Node.js는 현대 소프트웨어 개발에서 매우 중요한역할을 하고 있습니다. 그러한 역할은 산업 전반의 다양한 활용 사례를 통해 입증되고있습니다. 이 글은 그 활용 사례중 한 도입 사례를 한 발 더 깊이 연구해봅니다.무엇이 문제였는지, 그리고 그 문제 해결에 어떻게 도움이 되었는지 확인해 봄으로서Node.js의 가치를 좀 더 가늠해 보려합니다.</p><h2 id="배경"><a href="#배경" class="headerlink" title="배경"></a>배경</h2><p>넷플릭스는 2015년경부터 자사의 앱 스택에 Node.js를 적용하는데 그 당시 Netflix는사용자 사용 앱의 &#39;익터랙티브 시간&#39; (TTI: Time To Interactive) 를 줄이고자 하는목표를 가지고 있었습니다. &#39;익터랙티브 시간&#39; 이란 어플리케이션 최초 시작 시점부터UI 가 사용자에 의해 상호작용이 가능한 시간까지의 첫 시점을 의미합니다. 이TTI라는 지표를 원하는 수치 달성하기 위해 개선에 집중한 영역은 아래와 같았습니다.</p><p><img src="https://i.imgur.com/olZLFRt.png"></p><h3 id="서버-랜더링-클라이언트-렌더링-그리고-Universal-Javascript"><a href="#서버-랜더링-클라이언트-렌더링-그리고-Universal-Javascript" class="headerlink" title="서버 랜더링 - 클라이언트 렌더링, 그리고 Universal Javascript"></a>서버 랜더링 - 클라이언트 렌더링, 그리고 Universal Javascript</h3><p>웹 어플리케이션을 작성할때 애플리케이션의 특성과 요구사항에 따라 서버 혹은클라이언트 렌더링을 고려해 설계합니다. 서버 렌더링(Server-side rendering)은 웹애플리케이션에서 클라이언트 측에서 화면을 구성하는 대신 서버에서 HTML을 생성하여클라이언트에게 제공하는 방식입니다. 이는 클라이언트 측에서 자바스크립트를실행하여 화면을 동적으로 렌더링하는 클라이언트 사이드 렌더링(Client-siderendering)과 대조적인 방법입니다.</p><blockquote><p>서버 렌더링은 서버 측에서 마크업을 생성하므로 초기 로딩 속도가 개선될 수있습니다. 사용자는 초기 페이지 로드 후에 즉시 내용을 볼 수 있으며, 검색 엔진최적화 (SEO)에도 도움이 될 수 있습니다. 클라이언트 렌더링은 JavaScript를사용하여 동적인 UI를 쉽게 구현할 수 있습니다. 사용자의 상호작용에 따라즉각적인 업데이트와 상태 변경이 가능하며, 더 나은 사용자 경험을 제공할 수있습니다.</p></blockquote><p>서버 렌더링, 클라이언트 렌더링은 프로젝트의 목표, 성능 요구사항, 개발자 경험 및유지 보수 등을 고려하여 결정해야하나 넷플릭스가 Node.js 도입시 가졌던 문제는이러한 서버 렌더링과 클라이언트 렌더링을 유연하게 설계하는 것이 어려웠던것이었습니다. 그리고 그 어려움의 가장 큰 이유가 양측에서 사용하는 언어가 서로다른 점이었습니다.</p><p>두 언어를 상호 전환하는 데에는 기본적으로 비용을 수반하며, 렌더링을 유연하기위해 마크업을 개선하기 위해서는 클라이언트 코드와 너무 많은 직접적인 커플링이발생합니다. 이에 대한 여러 솔루션이 있으나 양쪽이 같은 언어를 사용했을때 언어의다름으로 인해 렌더링 결과의 미세한 차이가 발생 할 수 있는 있다는 것을확인하였으며 이로 인해 모든 마크업이 동일 언어에서 제공하는 한 API를 사용하여구성하는 것이 이상적이다라고 판단하게 되었습니다.</p><h3 id="Monolithic-아키텍쳐에서-Service-기반-아키텍쳐로"><a href="#Monolithic-아키텍쳐에서-Service-기반-아키텍쳐로" class="headerlink" title="Monolithic 아키텍쳐에서 Service 기반 아키텍쳐로"></a>Monolithic 아키텍쳐에서 Service 기반 아키텍쳐로</h3><p>Monolithic 은 &quot;하나로 통합된&quot; 이라는 의미를 가지며, 애플리케이션의 모든 구성요소가 단일한 실행 가능한 단위로 구성되는 것을 의미합니다. 일반적으로 단일코드베이스로 구성되며, 모든 기능과 서비스가 하나의 애플리케이션 내에 존재합니다.Netflix는 기존 앱은 Monolithic 한 형태로 설계되어 있었으며 [[Java EE]] (자바엔터프라이즈 에디션) 기반으로 작성되어 있었습니다.</p><blockquote><p>엔터프라이즈 자바(Enterprise Java)는 기업 환경에서 대규모 응용 프로그램을개발하고 구축하는 데 사용되는 자바 기반의 기술과 플랫폼을 가리킵니다.엔터프라이즈 자바는 자바 엔터프라이즈 에디션(Java EE) 스펙의 일부로 제공되며,기업급 시스템에서 안정성, 확장성, 보안성 등의 요구사항을 충족시키기 위한다양한 기능과 도구를 제공합니다.</p></blockquote><p>또 자체 데이터 서버를 가지고 있어 서버, 스토리지, 네트워크 장비 등을 직접관리하였습니다. 이러한 데이터 서버 유지 및 스케일링에 대한 관리 비용을효율화하고자, 인터넷 컴퓨터 리소스인 클라우드를 활용하기로 결정하였습니다.</p><p>Monolithic 아키텍처는 전체 어플리케이션을 단일 단위로 배포하고 실행합니다.그렇기 때문에 클라우드 환경에서는 기능의 독립적인 확장이 어렵고, 전체어플리케이션을 확장해야하기 때문에 리소스 사용이 비효율적일 수 있습니다. 또 개발및 배포가 어렵고, 장애발생시 회복시키거나 장애를 격리하기가 어렵습니다. 이러한이유로인해 Netflix는 기존의 Monolithic Java 서비스 였던 애플리케이션을 더 작은집합 (Microservice)으로 해체하고자 하였습니다.</p><h2 id="Node-js-와-React-js"><a href="#Node-js-와-React-js" class="headerlink" title="Node.js 와 React.js"></a>Node.js 와 React.js</h2><p>상기 두 개선 영역을 해결하고자 넷플릭스는 Node.js와 React.js를 도입하였습니다.Node.js 런타임내 React.js를 사용하여 서버와 클라이언트의 렌더링 로직을 공유할 수있었습니다. 예를 들어, React 컴포넌트를 서버 측에서 렌더링하여 초기 마크업을생성한 후, 클라이언트에서는 해당 컴포넌트를 가져와 상호작용을 처리하고 동적으로업데이트할 수 있습니다. 이를 통해 서버와 클라이언트 간에 렌더링 로직을 공유하여일관성을 유지하고 개발 유연성, 생산성을 향상시킬 수 있습니다.</p><p>또 Monolithic Java 서비스를 해체하여 구동하는데 Node.js를 활용하였는데, 그이유중 하나는 Node.js 가 마이크로 서비스 구축에 적합한 솔루션이였기때문이었습니다. Node.js는 싱글 스레드 이벤트 큐로 구성된 &#39;Event-Driven&#39;아키텍쳐를 가지고 있습니다. 이러한 구조는 비동기 I&#x2F;O 처리를 위해 많은 수의 동시요청을 처리할 수 있으며, 이벤트가 발생할 때 다른 서비스나 외부 시스템과의상호작용을 단순화 할 수 있습니다. Java 기반 애플리케이션 대비 시스템 구동,통신등에 있어 자원 사용 및 오버헤드가 적다는 것도 마이크로 서비스간 빈번한상호작용과 빠른 응답성에도 유리하였습니다.</p><h2 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h2><p>활용사례를 조사해보며 해당 기업이 Node.js를 도입하고자 했던 문제와 가치를 좀 더잘 이해할 수 있었습니다. 비슷한 문제를 가진 프로젝트와 기업에서도 Node.js를솔루션으로서 고려해 볼 수 있을것 입니다.</p><p>또한 어떤 한 솔루션이 프로덕션 레벨의 기술 스택으로 사용되기 위해서는 여러 가지신뢰성과 관련된 의문을 해결해야 하는데, 조사를 하며 Netflix를 비롯하여 이미 많은회사에서 Node.js를 자사 서비스 구조의 주요 축으로서 성공적으로 적용한 사례가있었습니다. 이는 현재 Javascript 런타임이 다양하게 등장하고 있는 시대에 있어서솔루션 선택에 있어서 중요한 지표가 될 수 있다고 생각됩니다.</p><h3 id="아래-다른-적용-사례에-대한-리스트를-첨부합니다"><a href="#아래-다른-적용-사례에-대한-리스트를-첨부합니다" class="headerlink" title="아래 다른 적용 사례에 대한 리스트를 첨부합니다"></a>아래 다른 적용 사례에 대한 리스트를 첨부합니다</h3><ul><li>NASA:<a href="https://openjsf.org/wp-content/uploads/sites/84/2020/02/Case_Study-Node.js-NASA.pdf">https://openjsf.org/wp-content/uploads/sites/84/2020/02/Case_Study-Node.js-NASA.pdf</a></li><li>Uber: <a href="https://www.uber.com/en-IN/blog/uber-tech-stack-part-two/">https://www.uber.com/en-IN/blog/uber-tech-stack-part-two/</a></li><li>ebay: <a href="https://clinejj.medium.com/building-with-node-js-at-ebay-9bbdf7d79b82">https://clinejj.medium.com/building-with-node-js-at-ebay-9bbdf7d79b82</a></li><li>Paypal: <a href="https://medium.com/paypal-tech/node-js-at-paypal-4e2d1d08ce4f">https://medium.com/paypal-tech/node-js-at-paypal-4e2d1d08ce4f</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/article/">article</category>
      
      
      <category domain="https://llnm.github.io/tags/node-js/">node.js</category>
      
      
      <comments>https://llnm.github.io/article/2023-07-07-nodejs-usecase-netflix/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>ChatGPT</title>
      <link>https://llnm.github.io/talk/2023-07-03-chatgpt/</link>
      <guid>https://llnm.github.io/talk/2023-07-03-chatgpt/</guid>
      <pubDate>Sun, 02 Jul 2023 15:00:00 GMT</pubDate>
      
        
        
      <description>&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/E2BBLlB.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;최근 ChatGPT가 너무나 충격적이어서 나의 언어로 이것이 무엇인지 기술해보기로 했다.
아래는 내가 정리해본 내용이다.&lt;/p&gt;
&lt;p&gt;ChatGPT는 Op</description>
        
      
      
      
      <content:encoded><![CDATA[<p><img src="https://i.imgur.com/E2BBLlB.jpg"></p><p>최근 ChatGPT가 너무나 충격적이어서 나의 언어로 이것이 무엇인지 기술해보기로 했다.아래는 내가 정리해본 내용이다.</p><p>ChatGPT는 OpenAI에서 개발한 대화형 인공지능 모델인 GPT를 기반으로 한 챗봇입니다.GPT 모델은 자연어 처리 기술을 활용하여 다양한 언어 작업을 수행하는 데 사용되며,그 중에는 자연스러운 대화 또한 포함된다. 현재 최신 모델은 GPT-4이다.</p><p>이 모델을 학습시키기 위해서는 많은 양의 텍스트 데이터가 필요하다. 이러한데이터는 인터넷에서 수집된 대화, 소설, 뉴스 기사, 블로그 포스트 등을 포함할 수 있다.그러나 이러한 데이터를 그대로 사용할 수는 없고 데이터를 모델 학습에 용이하도록 가공하고변환해야한다. 그 후에 모델은 이 변환된 데이터를 입력으로 활용하여 반복적으로 학습시킨다.</p><p>여기서 <code>학습</code>은 모델이 입력과 출력 간의 관계를 학습하여 주어진 입력에 대한 적절한출력을 생성하도록 조정하는 과정을 의미한다. 모델은 이전 문장을 분석하여 맥락을이해하고, 그에 기반하여 문장을 생성하는데, 생성된 문장의 오류를 최소화하기 위해모델은 지속적으로 업데이트되며, 이러한 과정에서 대용량의 데이터가 활용된다.</p><p>학습이 어려운 경우에는 인간의 지식과 경험을 활용하여 모델의 성능을 개선하는 데도움이 되는 강화학습(RLHF)을 활용하기도 한다. 그러나 대부분의 경우 GPT 모델은지도학습을 기반으로 학습된다.</p><ul><li><p>강화학습: 모델이 생성한 문장을 평가하고 자연스러움이나 의미적 일관성과 같은측면에서 평가 점수를 부여. 평가 점수는 모델이 보상으로 받게 되며, 모델은 이보상을 최대화하는 방향으로 문장 생성을 조정.</p></li><li><p>지도학습: 입력과 그에 대응하는 출력 사이의 관계를 학습하는 방법으로, 주어진 입력 데이터와그에 대한 정답(라벨)을 활용하여 모델을 훈련시키는 프로세스.</p></li></ul><p>ChatGPT는 다양한 분야에서 활용될 수 있다. 특히 자연어 처리 분야에서 뛰어난성능을 발휘하여 가상 비서와 같은 챗봇을 개발하는 데 매우 적합하다. 또한 뉴스기사 요약, 문서 생성, 언어 번역, 코딩 등 다양한 자연어 관련 문제를 해결하는데에도 활용될 수 있다.</p>]]></content:encoded>
      
      
      <category domain="https://llnm.github.io/categories/talk/">talk</category>
      
      
      <category domain="https://llnm.github.io/tags/ai/">ai</category>
      
      
      <comments>https://llnm.github.io/talk/2023-07-03-chatgpt/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
