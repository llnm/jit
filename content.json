{"meta":{"title":"DAEYEON JIT","subtitle":"Journey Into Tech.","description":"컴퓨터 기술 분야를 연구하며 그 과정에서 얻은 것들을 공유합니다. 현재는 웹 관련 기술, 특히 Node.js 같은 자바스크립트 런타임에 관심이 많습니다.","author":"Daeyeon Jeong","url":"https://llnm.github.io","root":"/"},"pages":[{"title":"About","date":"2023-06-23T06:50:56.000Z","updated":"2023-11-29T13:01:56.524Z","comments":false,"path":"about/index.html","permalink":"https://llnm.github.io/about/index.html","excerpt":"","text":"Greetings, ReadersI&#39;m Daeyeon Jeong, the creator of this blog. Within these pages, I explore various technical domains and share my discoveries along the way. Currently, I&#39;m delving into web-related technologies, with a specific focus on JavaScript runtimes like Node.js. What I Enjoy Away from Tech📚 Getting Lost in Novels: I have a strong penchant for reading novels. Escaping into a world different from reality is truly captivating. Reading can be a solitary hobby, yet that solitude is enchanting. 🍹 Exploring the World of Drinks: I&#39;m also quite intrigued by the world of alcoholic beverages. I enjoy learning about the intricate flavors of Korean spirits, whisky, wine, and more. The diverse tastes and fascinating histories behind these drinks capture my attention these days."}],"posts":[{"title":"WebAssembly 기술 동향","slug":"article-2023-11-27-wasm","date":"2023-11-26T15:30:20.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-11-27-wasm/","link":"","permalink":"https://llnm.github.io/article/2023-11-27-wasm/","excerpt":"","text":"WebAssembly (WASM)웹어셈블리(WebAssembly 또는 Wasm)는 다양한 프로그래밍 언어와 많은 실행 환경 사이의 중간 계층으로, 30여 가지 이상의 언어로 작성된 코드를 .wasm 파일로 컴파일한 다음 브라우저나 다른 실행 환경에서 실행할 수 있다. 원래 웹에서 코드 실행 속도를 높이기 위해 개발되었지만 이제는 브라우저 이외의 다양한 환경에서도 실행할 수 있다. WebAssembly는 발표된 시점에 비해 널리 사용되지 않았는데, 우선 언어 간 상호 호환성, 부족한 개발자 경험이 문제가 있었다. 또한 WebAssembly라는 이름 자체가 웹이나 어셈블리에 국한되지 않는데, Web이란 키워드를 쓰면서 잘못된 인상을 주었다. 이에 ’19년 모질라, 레드햇, 인텔, Fastly. 등의 회사들이 커뮤니티를 (Bytecode Alliance) 구축하였고, 브라우저를 벗어난 웹어셈블리 런타임에 대한 표준과 도구를 개발을 시작하였다. 현재 WASI (WebAssembly System Interface)를 구현한 WASM 런타임을 제공하고 있다. 특징 이식성 (Portable) - 한번 빌드하면 여러 플랫폼에서 활용가능 범용성 (Universal) - 많은 언어가 WASM으로 컴파일 가능 빠른 시작 시간 - Docker보다 10~100x 빠른 시작시간 안전성 (Secure) - 메모리 샌드박싱, 기능 제한 성능 - 네이티브에 가까운 성능 (1.5배 느림), JavaScript 보다는 항상 빠름 적용 예웹어셈블리의 적용 범위는 컨테이너화, 플러그인 시스템, 서버리스 컴퓨팅 플랫폼 등 기술 영역에서의 활발한 활용된다. 또한, 보안 측면에서도 샌드박스화된 외부 라이브러리의 안전한 실행, 제한된 권한 시스템, 그리고 라이브러리 격리 능력 등이 포함된다. WASM 적용 범위 참고: https://harshal.sheth.io/2022/01/31/webassembly.html WASI (WebAssembly System Interface)WASI(WebAssembly System Interface)는 웹 어셈블리 애플리케이션이 호스트 시스템과 상호 작용할 수 있도록 하는 표준 인터페이스이다. 이를 통해 웹 어셈블리 애플리케이션은 파일 시스템, 네트워킹 등의 시스템 리소스에 접근하도록 되었다. WASI가 등장하기 이전에는 Emscripten이 사용되었으며 자체적으로 JavaScript layer와 WASM layer로 구성해 브라우저와 통신해서 시스템 기능을 사용하였다. de-facto 표준으로 다뤄지나 속도나, Private API 사용등의 문제가 있다. (https://hacks.mozilla.org/2019/03/standardizing-wasi-a-webassembly-system-interface/) WASI 사용 모듈과 Node.js 모듈 비교 Portability: WASM 모듈은 Write one time, Use everywhere이 고려되었다. Node.js Native 모듈이 환경마다 node-gyp를 통해 빌들을 수행하는 것에 비해 한번 빌드된 형태로 그대로 배포가 가능하다. Security: Capability-based security 전략을 사용한다. &quot;권한이 프로그램 단위가 아니라 모듈 단위&quot;로 이루어지고, 모듈 단위로 전파될 때 권한에 대한 수정도 가능하다. Node.js에서도 Permission 모델이 구축되고 있지만, 런타임 단위의 보안을 제공하고 모듈 단위의 제어는 불가하다. (관련된 Node.js 해킹사례: electron-native-notify NPM 모듈의 ZipSlip) Capability-based security 전략에서 각각의 개체(사용자, 프로세스, 모듈 등)는 자신이 필요로 하는 특정한 능력을 가지고 있어야만 특정 능력을 수행할 수 있다. 예를 들어, 파일에 액세스해야 하는 함수를 호출하는 경우, 해당 함수는 파일에 대한 적절한 권한이 부여된 능력을 가진 객체에게만 실행되도록 할 수 있다. 이를 통해 권한이 필요한 동작을 수행하는 데 필요한 최소한의 권한만 부여할 수 있게 되며, 보안을 강화할 수 있다. 3rd party NPM 모듈 Vulnerability를 보장할 수 없기 때문에 Node.js 런타임은 실제 Production 에서 사용되기기 어렵다. 이에 비해 WASM 모듈은 WASI 인터페이스가 Sandboxing을 고려하여 설계되어있다. 표준화현재 WASI의 모든 API는 Proposal 단계 (Phase 2) 이다. 아직 실험적 상태에고 인터페이스가 변경이 가능함을 의미한다. 자세한 현황은 https://github.com/WebAssembly/WASI/blob/main/Proposals.md 를 참조할 수 있다. WASM Runtime 현황브라우저 외부에서 WASM을 사용할 수 있는 Runtime은 다음과 같다. Bytecode Alliance, Standalone Runtime wasmtime: WSAM Standalone Runtime, wasi-core, (Standard compliant), 브라우저용 WASI Polyfill, WAMR (WebAssembly Micro Runtime): Binary size 85K (interpreter) and 50K (AOT) and low memory usage QuickJS 기반 JS 인터페이스 제공 Wasmer (https://medium.com/wasmer/wasmer-1-0-3f86ca18c043) WASMedge (https://wasmedge.org) CJS NPM 모듈은 rollup.js을 통해 번들링하여 사용, https://wasmedge.org/book/en/write_wasm/js/tensorflow.html Cloudflare Workerd (https://github.com/cloudflare/workerd) Workers 서비스의 Core, 분산 컴퓨팅 Microservice 운용에 특화 Node.js WASI: application&#39;s sandbox directory structure, stdio&#x2F;out&#x2F;stderr 제공 (Experimental) https://webassembly.org/roadmap/ Web Container WASM으로 Node.js 개발환경을 아에 제공. JS를 직접 돌림. Node 14. 지원 https://github.com/stackblitz/webcontainer-core Blazor Flutter 같은 웹 F&#x2F;W, C# 기반으로 작성, 브라우저에서는 WASM을 이용 Containerization서버 어플리케이션 배포에 용이한 Docker에 비해 WASM은 콜드 스타트 ​​시간이 10~100배 빠르며 메모리 사용량이 적고 뛰어난 보안 모델을 채용하고 있다. 컨테이너가 아닌 WASM 모듈이 연산 및 배포의 최소 단위가 될 가능성이 높으나, 한번에 Docker를 완전히 대체하지는 않고 기존 오케스트레이션 시스템에 통합되는 형태로 진행될 것이라 예측된다. 이러한 흐름과 별개의 Containerization 기술은 아래와 같다. Lightweight VirtualizationLightweight Virtualization은 전통적인 가상화 기술과는 다르게 더 가벼운 방식으로 가상화를 구현하는 기술을 말한다. 더 적은 오버헤드와 빠른 부팅 시간을 제공하면서도 격리와 보안을 유지한다. AWS Firecracker가 이러한 Lightweight Virtualization 기술의 한 예로, 멀티 테넌시 환경에서 안전하게 컨테이너를 실행하도록 되어있다. KVM(Kernel-based Virtual Machine)을 기반으로 하며, 커널 기능을 최소화하여 경량화된 가상화를 제공한다. 참고자료: https://www.koyeb.com/blog/lightweight-virtualization-the-container-ecosystem-and-firecracker-microvms-for-serverless JavaScript ContainerJavaScript Container는 Node.js의 한계와 함께 등장한 새로운 개념으로, 브라우저 API 디자인 개념을 공유함으로써 웹 개발자들이 JavaScript 런타임을 사용할 때 배워야 할 개념을 줄일 수 있는 장점을 갖는다. 또, 메모리 사용량보다는 인스턴스 사용 시간이 중요한 Serverless 환경에서 빠른 재구동 시간을 제공하여 비용을 절감할 수 있다. 기존의 Microservice 아키텍처를 더 작은 단위의 컴포넌트로 분리하는 새로운 애플리케이션 아키텍처 구축이 가능하다. (Linux Container를 대체하는 것이 아니라 고성능 및 경량을 요구하는 일부 분야에서 광범위한 애플리케이션 적용 예상) 예: CloudFlare Worker (JS Container &#x2F; Worker, v8::Isolate) Node.js 가 개별 장치의 앱 제작을 위해 만들어졌다면 Worker는 CloudFlare 특화 분산 네트웍 컴퓨팅을 위해 만들어짐 https://developers.cloudflare.com/workers 예: Deno deploy (JS Container) Web Platform APIs 기반, 프로그래머가 알아야 할 개념들을 최소화 + Single Executable, No NPM, TypeScript, CLI https://deno.land https://tinyclouds.org/javascript_containers References https://webassembly.org https://bytecodealliance.org Pay attention to WebAssembly NodeJS Native Module vs WASM","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"JavaScript Object의 생명주기 관리","slug":"article-2023-11-26-js-object-lifetime","date":"2023-11-25T15:30:20.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-11-26-js-object-lifetime/","link":"","permalink":"https://llnm.github.io/article/2023-11-26-js-object-lifetime/","excerpt":"","text":"Node.js Core 에서 JavaScript 생명주기를 관리하는 방법을 알기 위해서는 V8 API를 통해 메모리를 관리하는 컨셉을 이해할 필요가 있다. 모든 JavaScript 값은 V8 API를 통해 소위 핸들이라는 것을 통해 액세스된다. 이 핸들은 메모리 관점에서 Local과 Global이란 타입으로 나뉜다. 메모리 관리 타입v8::Localv8::Local 이란 JavaScirpt 값이 다뤄지는 현재의 Local Block 영역 (Stack) 에서만 유효한 핸들을 의미한다. Local Block을 벗어나면 값은 유효하지 않게 된다. 값이 Referencing 되고 있는지에 따라 GC (Gabage Collector)를 수행하는 JavaScript 엔진 측면에서 메모리 관리는 중요한데, 기본적으로 C++ 에서 모든 JavaScript 값에 대해서 Local 핸들로서 관리함으로서 메모리의 leak을 방지한다. 즉 임시적으로 사용할 메모리는 모두 Local 핸들로서 직관적으로 다뤄진다. v8::Local 은 JavaScript 핸들이 어떤 메모리 영역에서 관리되야하는지를 나타내는 Reference일 뿐 Local 메모리 생성을 의미하지는 않는다. Local 핸들을 생성하기 위해선 Stack 영역에 v8::HandleScope 또는 v8::EscapableHandleScope 객체를 생성해야한다. 생성된 이후 Local::New API를 사용하면 실제 Local 메모리에 적재된 JavaScript 값을 생성할 수 있고 마지막으로 생성한 Scope 객체에 메모리 영역이 잡히게 된다. 그러나 Node.js 에서 바인딩 함수 내부에 있는 경우는 Handle의 범위가 함수 외부에 이미 존재하므로 별도로 만들 필요가 없다. v8::EscapableHandleScope는 Scope 내에서 생성된 v8::Local을 Scope 외부로 넘기고자할때 사용할 수 있다. v8::EscapableHandleScope 객체의 Escape API로 생성한 v8::Local 인스턴스를 넘기면 해당 영역 외부의 메모리 Scope로 전달된다. v8::Global특정 Scope내에서만 유요한 v8::Local과 다르게 다르 v8::Global 로 관리되는 핸들은 Scope와 관계없이 유지되며 GC 대상이 되지 않을 수 있다. 정확히 말하면 Global 핸들의 Strong 상태에서 GC 되지 않는다. Global 핸들은 Weak 상태로 변경할 수 있으며, Weak 상태가 되었을 때 GC 메카니즘에 의해 메모리가 릴리즈 될 수 있다. 그런데, 그냥 릴리즈 되는 것이 아니라 GC 메카니즘에 의해 메모리 릴리즈 되기 직전에 등록된 Callback을 통해 통보받는다. 그 시점에서 다시 Strong으로 변경할지 Weak를 유지하여 릴리즈를 할지 결정이 가능하다. 1234567void function(v8::Isolate* isolate, v8::Local&lt;v8::Object&gt; obj) &#123; ... // Global의 Reset() 함수를 이용하여 Local 영역에 있는 obj 핸들을 Global로 이동시킨다. // 이동이 되면 기본적으로 Strong 상태로 핸들을 관리한다. v8::Global&lt;v8::Object&gt; reference = reference.Reset(isolate, obj); ...&#125; 생명주기 관리JavaScript 엔진은 Gabage Collector를 주기적으로 실행하여 어떤 객체도 Referencing하지 않는 객체에 대해 제거한다. 사용자가 JavaScript 객체를 Referencing 하지 않더라도 Core는 필요에 따라 특정 JavaScript 객체가 엔진에 의해 제거되는 것을 방지해야한다. 그렇게 하기 위해서 JavaScript Object의 InternalField 에 C++ 클래스 인스턴스를 저장하고, JavaScript Object에 대한 메모리 영역을 Local에서 Global로 변경한다. 이 동작은 Node.js에서 객체와 바인딩되는 모든 Class의 부모 Class인 BaseObject 의 생성자에서 수행된다. v8::Global&lt;v8::Object&gt; 타입 변수 persistent_handle_에 Local 객체를 등록함으로서 상기 Code에서 Reset을 호출한것과 같이 Global 메모리 영역으로 JavaScript 값을 이동시킨다. Weak 상태로 변경v8::Global의 SetWeak API는 현재 Strong으로 관리되고 있는 메모리를 Weak 상태로 변경함으로서 GC 시 메모리를 릴리즈 할 수 있게 한다. 12345678910111213141516171819202122232425void BaseObject::MakeWeak() &#123; .... persistent_handle_.SetWeak( this, // (a) Callback으로 전달할 포인터 [](const WeakCallbackInfo&lt;BaseObject&gt;&amp; data) &#123; // (a) 에서 전달한 BaseObject 포인터를 parameter로서 획득한다. BaseObject* obj = data.GetParameter(); /* ~BaseObject에서 internal field를 clean up 하는 부분이 있는데 GC에 의해 삭제된 경우는 굳이 해당 동작을 하지 않도록 한다. */ obj-&gt;persistent_handle_.Reset(); // BaseObject 인스턴스가 연결되어있던 JavaScript 객체는 이제 삭제되니, 이 // BaseObject도 삭제되어야한다. OnGCCollect 함수에서는 delete this를 수행한다. obj-&gt;OnGCCollect(); &#125;, // (b) Callback에 전달 가능한 타입은 kParameter 와 kInternalFields 이며 // kInternalFields 타입은, 지정된 internal field의 첫 두 field를 전달한다. WeakCallbackType::kParameter);&#125; 상기 코드는 BaseObject의 MakeWeak함수의 일부이다. SetWeak를 통해 GC 발생시점에 콜백을 등록하고 Strong 에서 Weak 핸들로 변경한다. 자바스크립트 객체가 가비지 컬렉션되기 전에 등록된 콜백이 호출된다. BaseObject::OnGCCollect()를 호출하면 BaseObject 인스턴스가 삭제된다. SetWeak 등록된 후 BaseObject::ClearWeak()를 호출하여 Strong상태로 다시 변경할 수 있다. 일반적으로 해당 서브클래스가 이벤트 루프 등에서 참조되지 않는 한, HandleWrap 및 ReqWrap 클래스의 경우처럼 해당 서브클래스의 생성자에서 MakeWeak()를 호출하는 것이 합리적입니다. Smart Pointer for BaseObjectBaseObjectPtrBaseObject의 서브클래스 T의 객체를 Shared Pointer로서 보유한다. 즉, 이 포인터를 가지고 있는동안은 BaseObject는 Strong 참조를 유지한다. BaseObject는 JavaScript 객체의 생명주기를 따르나 Detach()가 호출된다면 BaseObject를 JavaScript 객체의 생명주기로 부터 분리해낼수 있다. 이 경우 BaseObjectPtr 를 참조하는 마지막 포인터가 제거되면 BaseObject는 릴리즈된다. BaseObjectWeakPtrBaseObject의 서브클래스 T의 객체를 Weak Pointer로서 보유한다. Garbage Collection이 발생해 BaseObject가 제거되면 std::weak_ptr&lt;T&gt;와 유사하게 weak_ptr.get()의 값으로 nullptr가 반환된다. v8: State transition diagram1FREE -&gt; NORMAL &lt;-&gt; WEAK -&gt; PENDING -&gt; NEAR_DEATH -&gt; &#123; NORMAL, WEAK, FREE &#125;","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Node.js C++ Core Concept","slug":"article-2023-11-24-memory-management","date":"2023-11-23T15:30:20.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-11-24-memory-management/","link":"","permalink":"https://llnm.github.io/article/2023-11-24-memory-management/","excerpt":"","text":"JavaScript와 C++ 간의 효율적인 연결은 Node.js에서 중요한 문제 중 하나이다. 이러한 연결을 가능하기 위해 Node.js Core에서는 기본 C++ 클래스로 BaseObject 사용한다. BaseObject는 JavaScript 객체와 C++ 객체를 함께 묶는 주요 추상화 수단으로, 이를 통해 메모리 관리와 더불어 객체의 수명 주기를 관리할 수 있다. BaseObjectNode.js에서 JavaScript 객체와 연관된 대부분의 클래스는 BaseObject 의 subclass이다. BaseObject의 상위 클래스는 MemoryRainer인데, V8 Heap snapshot builder에서 메모리 추적을 위해 C++ 클래스에 Annotation을 할 수 있도록 하는 Helper 클래스라고 한다. 메모리 릭에 대한 디버깅 용도로 사용할 수 있다. 모든 BaseObject는 하나의 Realm과 하나의 v8::Object 와 연관된다. v8::Object 클래스는 JavaScrip Object를 뜻한다. 이 클래스의 인스턴스에는 internal field라고 하는 공간을 할당할 수 있다. 이 공간에 BaseObject의 나 하위 Class의 포인터를 연결함으로서 JavaScript Object 와 C++ 클래스 인스턴스를 바인딩한다. Internal Field에 반드시 BaseObject의 서브클래스만 등록해야하는 것은 아니다. InternalField에 얼마나 많은 정보를 넣을지는 V8 API의 SetInternalFieldCount() 를 통해 설정할 수 있다. base_object.cclink2122232425262728BaseObject::BaseObject(Realm* realm, Local&lt;Object&gt; object) : persistent_handle_(realm-&gt;isolate(), object), realm_(realm) &#123; CHECK_EQ(false, object.IsEmpty()); CHECK_GE(object-&gt;InternalFieldCount(), BaseObject::kInternalFieldCount); SetInternalFields(realm-&gt;isolate_data(), object, static_cast&lt;void*&gt;(this)); realm-&gt;AddCleanupHook(DeleteMe, static_cast&lt;void*&gt;(this)); realm-&gt;modify_base_object_count(1);&#125; 상기 BaseObject 생성자 함수에서 확인 할 수 있듯이 SetInternalFields 를 이용해 Local 메모리 영역의 object에 BaseObject 인스턴스 자신 (this) 를 설정한다. Accessing BaseObjectC++레벨에서 JavaScript Object로 부터 BaseObject에 대한 포인터를 얻는 방법은 Unwrap&lt;T&gt; 를 사용한다. 보통 JavaScript 객체의 Function Callback의 호출되었을때 arg.This() 나 arg.Holder() 로 부터 얻을수 있다. (args.Holder()는 Node.js 내부의 모든 사용 사례에서 args.This()와 동일). Unwrap&lt;T&gt;() 는 반환받는 Pointer를 미리 Casting하려는 용도의 Alias 함수이다. 내부적으로는 BaseObject::FromJSObject 에 의해서 v8::Object부터 기 지정한 internal field로 부터 Pointer를 얻어온다. base_object.hlink246247248249250251#define ASSIGN_OR_RETURN_UNWRAP(ptr, obj, ...) \\ do &#123; \\ *ptr = static_cast&lt;typename std::remove_reference&lt;decltype(*ptr)&gt;::type&gt;( \\ BaseObject::FromJSObject(obj)); \\ if (*ptr == nullptr) return __VA_ARGS__; \\ &#125; while (0) AsyncWrapAsyncHook은 비동기 요청(init&#x2F;destory)의 수명 및 해당 콜백 활동(Before&#x2F;After)을 추적하는 기능을 제공한다. 이를 위한 추가적인 정보와 도구를 제공하는 BaseObject의 서브클래스가 AsyncWrap이다. AsyncHook에서 명시되었던 것과 같이 어떤 Core 모듈이 해당 Async동작을 수행했는지를 추적하기 위한 unique id가 있다. async_wrap.hlink3435363738394041424344#define NODE_ASYNC_NON_CRYPTO_PROVIDER_TYPES(V) \\ V(NONE) \\ V(DIRHANDLE) \\ V(DNSCHANNEL) \\ V(ELDHISTOGRAM) \\ V(FILEHANDLE) \\ V(FILEHANDLECLOSEREQ) \\ V(BLOBREADER) \\ V(FSEVENTWRAP) \\ V(FSREQCALLBACK) \\ V(FSREQPROMISE) \\ AsyncHook을 도입할때 비동기 연산에 대한 디버깅을 쉽게하기 위함이었을것 같다. (TODO: 향후 History를 찾으면 다시 업데이트 하겠다.) 그러나, 최근 FS 모듈에 대한 Async File Read를 분석해보니 Tracing을 단일 Operation 단위로 처리될 수 있도록 고정되어있어 통합된 비동기 동작에 대한 Tracing 처리를 만들기가 어려웠다. 또, Node.js 에서는 공식적으로 AsyncHook에 대한 기능 사용을 권하지 않는다. 따라서, 향후 어떤 방향이든 개선이 필요한 클래스이다. AsyncWrap 클래스에서 중요한 함수는 MakeCallback을 들수 있다. Callback을 만들기 위한 함수명 처럼 보이지만 이름과는 다르게 실제의미는 C++에서 JavaScript 쪽으로 Callback을 부르는 용도를 한다. 참고로 이러한 JavaScript와 C++ 사이의 Context Switching이 일어나는 경우 Cost가 많이 들기 때문에 되도록 적게 부르는 것이 Performance 측면에서 좋다. 123456789101112131415161718192021void StatWatcher::Callback(uv_fs_poll_t* handle, int status, const uv_stat_t* prev, const uv_stat_t* curr) &#123; // StatWatcher 는 AsyncWrap의 서브 클래스 StatWatcher* wrap = ContainerOf(&amp;StatWatcher::watcher_, handle); Environment* env = wrap-&gt;env(); // Integer::New 로 할당을 하기 때문에 HandleScope를 잡아준다. HandleScope handle_scope(env-&gt;isolate()); Context::Scope context_scope(env-&gt;context()); ... // C++에서 JavaScript 쪽으로 전달할 argument Local&lt;Value&gt; argv[] = &#123; Integer::New(env-&gt;isolate(), status), arr &#125;; // wrap 인스턴스에 연결된 객체에 프로퍼티중 onchange 에 등록된 콜백을 호출 wrap-&gt;MakeCallback(env-&gt;onchange_string(), arraysize(argv), argv);&#125; Libuv Handlerslibuv에서 이벤트 루프와 상호작용하는 데 사용되는 타입이 있는데 handle과 request이다. uv.h를 살펴보면 아래와 같이 정의된 타입을 확인할 수 있다. uv.hlink217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247/* Handle types. */typedef struct uv_loop_s uv_loop_t;typedef struct uv_handle_s uv_handle_t;typedef struct uv_dir_s uv_dir_t;typedef struct uv_stream_s uv_stream_t;typedef struct uv_tcp_s uv_tcp_t;typedef struct uv_udp_s uv_udp_t;typedef struct uv_pipe_s uv_pipe_t;typedef struct uv_tty_s uv_tty_t;typedef struct uv_poll_s uv_poll_t;typedef struct uv_timer_s uv_timer_t;typedef struct uv_prepare_s uv_prepare_t;typedef struct uv_check_s uv_check_t;typedef struct uv_idle_s uv_idle_t;typedef struct uv_async_s uv_async_t;typedef struct uv_process_s uv_process_t;typedef struct uv_fs_event_s uv_fs_event_t;typedef struct uv_fs_poll_s uv_fs_poll_t;typedef struct uv_signal_s uv_signal_t;/* Request types. */typedef struct uv_req_s uv_req_t;typedef struct uv_getaddrinfo_s uv_getaddrinfo_t;typedef struct uv_getnameinfo_s uv_getnameinfo_t;typedef struct uv_shutdown_s uv_shutdown_t;typedef struct uv_write_s uv_write_t;typedef struct uv_connect_s uv_connect_t;typedef struct uv_udp_send_s uv_udp_send_t;typedef struct uv_fs_s uv_fs_t;typedef struct uv_work_s uv_work_t;typedef struct uv_random_s uv_random_t; Handle은 파일 디스크립터, 타이머, 혹은 다른 리소스와 관련된 이벤트를 추적하는 데 사용된다. 이벤트 루프가 이러한 이벤트를 감지하고 처리할 수 있도록 핸들을 등록하고 관리한다. Request는 비동기 작업을 수행하고 완료되었을 때 결과를 처리하는 데 사용된다. 파일 읽기, 쓰기, 혹은 네트워크 요청과 같은 작업을 수행할 때 request를 생성하여 완료되었을 때의 콜백을 등록한다. Libuv Handle Wrapper ClassHandleWrapHandleWrap은 AsyncWrap의 서브클래스이며 uv_handle_t 와 같은 libuv의 핸들을 감싸서 관리하는 용도로 사용된다. .ref(), .unref(),.hasRef(),.close() 등의 함수가 제공되는데, 함수 내부적으로 libuv의 uv_ref(), uv_unref() 와 같은 API를 호출한다. 1234567void HandleWrap::Ref(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; HandleWrap* wrap; ASSIGN_OR_RETURN_UNWRAP(&amp;wrap, args.Holder()); if (IsAlive(wrap)) uv_ref(wrap-&gt;GetHandle());&#125; ReqWrapReqWrap AsyncWrap의 서브클래스이며 uv_req_t 와 같은 libuv의 request를 쉽게 처리하는 기능을 제공한다. 예를들면 파일을 읽는 동작을 uv_fs_t request 핸들을 이용하여 전달할때 요청된 동작이 끝나면 결과 Callback이 호출되도록 등록한다. ReqWrap::Dispatch() 메서드는 이러한 동작을 일관된 방법으로 사용할 수 있게한다. req_wrap-inl.hlink137138139140141142143144145146147148149150151152153154155156157158159160161162163164165template &lt;typename T&gt;template &lt;typename LibuvFunction, typename... Args&gt;int ReqWrap&lt;T&gt;::Dispatch(LibuvFunction fn, Args... args) &#123; Dispatched(); // This expands as: // // int err = fn(env()-&gt;event_loop(), req(), arg1, arg2, Wrapper, arg3, ...) // ^ ^ ^ // | | | // \\-- Omitted if `fn` has no | | // first `uv_loop_t*` argument | | // | | // A function callback whose first argument | | // matches the libuv request type is replaced ---/ | // by the `Wrapper` method defined above | // | // Other (non-function) arguments are passed -----/ // through verbatim int err = CallLibuvFunction&lt;T, LibuvFunction&gt;::Call( fn, env()-&gt;event_loop(), req(), MakeLibuvRequestCallback&lt;T, Args&gt;::For(this, args)...); if (err &gt;= 0) &#123; ClearWeak(); env()-&gt;IncreaseWaitingRequestCounter(); &#125; return err;&#125;","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Realm Class","slug":"article-2023-11-23-realm","date":"2023-11-22T15:30:20.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-11-23-realm/","link":"","permalink":"https://llnm.github.io/article/2023-11-23-realm/","excerpt":"","text":"2022년 Node.js 에는 Realm Class가 추가되었다. Realm은 주로 실행 환경을 정의하고 코드 간의 격리와 분리를 유지하기 위한 목적으로 사용된다. 기존 Node.js VM 모듈이 있으나 Node.js 자체 기능이고 JavaScript Object Graph가 노출될 가능성이 있다. 그에비해 새롭게 도입된 Realm은 보안측면에서 강화된 JavaScript 실행환경을 제공한다. ECMAScript Realm정의와 구성요소ECMAScript realm은 ECMAScript 스펙상의 개념이다. 이 용어는 코드 실행 컨텍스트, 실행 환경 및 연관된 객체의 집합을 나타내는데, 간단히 말해서 코드가 실행되고 변수, 함수, 객체 등이 존재하는 공간이라고 볼 수 있다. 다음은 Realm의 종류이다. Principal Realm: 각각의 ECMAScript 실행 환경에서 하나씩만 존재하는 특수한 Realm. 이 Realm은 주로 코드 실행에 사용되며, 전역 객체와 스코프를 포함하는 주 실행 컨텍스트를 정의한다. Synthetic Realm: JavaScript 코드에서 명시적으로 생성되는 가상의 Realm. 주로 코드 분리 및 격리를 위해 사용된다. 각 Synthetic Realm은 자체의 전역 객체와 스코프를 갖고 있다. 모듈 시스템과 관련이 있어, 모듈 간의 격리를 유지하고 코드의 독립성을 증가시키는 데 사용된다. ECMAScript realm은 구성 중 일부는 다음과 같다. Global Object: 각 realm은 전역 객체를 가지고 있으며, 이 객체는 해당 realm에 속한 모든 전역 변수와 함수를 포함함. 브라우저 환경에서는 window, Node.js에서는 global이 전역 객체에 해당한다. Global Scope: 전역 객체의 스코프에 속하는 변수와 함수는 전역 스코프에 존재하며 realm 전체에서 접근 가능한 범위를 의미한다. Intrinsics: 각 realm은 특정한 빌트인 객체와 함수를 갖는다. Object나 Array와 같은 객체 생성자들이 여기에 속한다. Declarative Environment Records: 변수 선언 등과 같은 정보를 저장하는 객체. Object Environment Records: 전역 객체 등과 같은 객체에 대한 참조를 유지하는 객체 구성요소에 관한 더 상세한 내용은 아래 링크를 참조한다. ECMAScript® 2024 Language Specification (tc39.es) Realm ClassNode.js 에서 Realm 클래스는 특정 ECMAScript 영역과 연관된 JavaScript 객체 및 함수 집합을 위한 컨테이너이다. 각 ECMAScript 영역에는 Global Object와 Intrinsics 집합이 있다. ECMAScript 영역에는 [[HostDefined]] 필드가 있으며, 이 필드는 Node.js 영역 객체를 나타낸다. 모든 Realm 인스턴스는 Context에서 생성된다. Node.js 내에서 Realm 은 본 개념과 같이 principal realm 과 synthetic realm으로 생성될 수 있다. principal realm는 Node::Environment의 main Context에서 생성된다. synthetic realm은 ShadowRealm의 Context (JavaScript API에 의해 생성됨) 에 대해 생성된다. vm.Context에는 Realm instance를 생성하지 않는다. ShadowRealm을 이용한 IsolationNode.js 가 도입한 내용은 Synthetic Realm을 이용한 객체 참조 (Object Graph) 의 격리를 보장하는 것이다. 아래의 예를 들면 (1) 에서 vm에서 생성된 함수가 외부의 객체를 접근할 수 있는데 이러한 참조를 Synthetic Realm을 통해 격리시킬 수 있다. 1234let ctx = vm.createContext();let fn = vm.runInContext(&#x27;...&#x27;, ctx);fn(&#123;&#125;); // &lt;= (1) vm에서 생성된 함수가 외부 `Object`에 액세스하여 메서드에 접근할수 있다. ShadowRealm tc39&#x2F;proposal-shadowrealm: ECMAScript Proposal, specs, and reference implementation for Realms (github.com) Synthetic Realm을 생성하기 위해 Node.js는 TC39 3단계 제안상태인 ShadowRealm 기능을 사용한다. ShadowRealm은 서로 다른 자바스크립트 실행 컨텍스트 간의 객체 그래프 격리를 보장하고, 새로운 빌트인을 도입하여 별개의 글로벌 환경을 제공한다. 또한 ShadowRealm은 사용하는 모듈 그래프가 외부 영역으로부터 격리되도록 보장한다. ShadowRealm은 모든 주요 영역 (main thread 환경 &#x2F; worker thread 환경), 다른 ShadowRealm 및 vm.Context에서 생성할 수 있다. VM과 비교하면 ShadowRealm은 URL, TextEncoders 등과 같이 Node.js 에서 공통인 API가 내장되어 있다. 따라서 더 쉽게 일반적인 JavaScript 코드를 실행할 수 있다. Node.js 에서 Realm을 계층적으로 구조한 디자인을 정리하면 다음과 같다. Environment (Main thread 나 Worker threads, ECMAScript agent를 나타낸다) worker_contexts: worker 가 객체를 처리한다. handle objects. principal_realm: principal realm (v8::Context) 과 관련된 데이터 synthetic_realms: Synthetic realms. time origin. Realm (realm record, principal realm, ShadowRealm, vm.Context): context: 실행 context. principal realm을 나타내는 플래그 module map. Per-context persistent handles. … principal realm과 synthetic realm 간 공통인 데이터 각 Realm은 여러 개의 synthetic realm 을 생성할 수 있다. Realm의 도입으로 Node::Environment는 이벤트 루프, Inspector 등 여러 Realm에서 공유할 수 있는 기타 여러 가지를 소유하는 Thread&#x2F;Execution environment&#x2F;ECMAScript 에이전트의 레코드로 해석할 수 있다. Bootstrapping 순서node::Environment Principal realm 설정 InitializeContext internal&#x2F;per_context&#x2F;primordials internal&#x2F;per_context&#x2F;domexception internal&#x2F;per_context&#x2F;messageport Environment::RunBootstrapping internal&#x2F;bootstrap&#x2F;loaders internal&#x2F;bootstrap&#x2F;node node global extensions and the process object 설정 internal&#x2F;bootstrap&#x2F;browser web API global extensions 설정 internal&#x2F;bootstrap&#x2F;switches&#x2F;{is_main_thread, is_not_main_thread} internal&#x2F;bootstrap&#x2F;switches&#x2F;{does_own_process_state, does_not_own_process_state} LoadEnvironment internal&#x2F;main&#x2F;* internal&#x2F;bootstrap&#x2F;pre_execution SyntheticEnvironment의 경우, (1) 및 (2) 단계는 node::Environment의 principal realm 와 유사하다. (2)에서 글로벌을 internal&#x2F;bootstrap&#x2F;switches로 초기화하는 스크립트를 node::Environment의 principal realm과 Synthetic Realm에 대해 분할해야 한다. (Synthetic Realm에서 특정 글로벌을 노출하지 않는 것과 같은 방식) global 설정 global: internal&#x2F;bootstrap&#x2F;node setupGlobalProxy process: internal&#x2F;bootstrap&#x2F;node Buffer: internal&#x2F;bootstrap&#x2F;node Web interfaces: internal&#x2F;bootstrap&#x2F;browser References https://weizmangal.com/2022/10/28/what-is-a-realm-in-js/ https://developer.salesforce.com/blogs/2022/04/introducing-shadowrealm https://github.com/nodejs/node/pull/44179","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Server JavaScript Runtime 기술 동향","slug":"article-2023-11-22-javascript-runtime","date":"2023-11-21T15:13:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-11-22-javascript-runtime/","link":"","permalink":"https://llnm.github.io/article/2023-11-22-javascript-runtime/","excerpt":"","text":"브라우저 외부에서 JavaScript를 사용할 수 있는 Node.js가 등장한 이후 산업전반에서 다양하게 활용되며 De-facto 표준으로 자리잡았다. 현재는 Node.js의 결점을 보완하거나, 각 회사에 최적화 된 자체 솔루션으로 대체하는 방향으로 JavaScript 런타임이 파편화되고 있으며, 개발자들에게 통합된 개발 API을 제공하기 위한 각 런타임 간 상호운용성에 대해 논의 중이다. 신규 Server&#x2F;Edge JavaScript Runtime의 주요 기능신규 Runtime들은 각각 차별되는 다양한 기능을 가지고 있으며 Node.js 대비 크게 보안, 성능, 모듈 복잡성 개선, 향상된 DX 제공 등을 주요 목표로 하고 있다. Deno는 보안 측면에서 Node.js가 시스템 자원의 사용에 대해 어떠한 제한도 두고 있지 않는 것에 비해, 사용자가 사용하는 외부 모듈에 대해서 투명하게 공지하고 제한하는 기능을 제공한다. Bun은 Network&#x2F;DB 테이블 로딩등의 성능에 있어서 유의미한 차이를 제공하며, Workerd는 여러 앱을 하나의 Runtime에서 실행하여 메모리 사용량 및 Cold Start 속도를 향상시킨다. Core API에 여러 기능이 포함되는 것을 지양한 Node.js에 비해, 신규 Runtime에서는 모던 JavaScript 앱 개발시 빈번하게 사용되는 필요한 기능 (예: Transpiler, Package manager, Bundler, Test Runner 기능등)을 Core 기능으로 포함시켜 DX를 향상시키고 있다. 공통적인 특징은 각 Runtime의 Core API의 디자인을 Web Platform API을 기반으로 하였다고, 새로운 기능을 제공하면서 많은 Eco를 확보하고 있는 Node.js Core API의 호환성을 보완한다는 점이다. 그리고, Node.js 또한 이러한 신규 Runtime의 영향으로 보안, 성능, DX 향상등에 점진적으로 보완해가는 중이다. Denoland - Deno (https://deno.com/) V8 엔진 기반, Rust로 Core 작성, TypeScript 지원, Web Platform API 호환성 제공 FileSystem, Network, Script Execution 등에 대한 Permissions Model 제공 NPM과 같은 중앙집중형 모듈 저장소를 사용하지 않음 Oven - Bun (https://bun.sh/) JavaScriptCore 엔진, Zig 언어로 Core 작성, TypeScript 지원, Web Platform API 호환성 제공 Cold Start 시간, Network&#x2F;DB Request 처리 시간 등 성능에 최적화 FFI(foreign function interface) 기능, 내장 SQLite3 지원 All-in-one DX 제공 (Package Manager, Bundler, Test Runner등이 Runtime에 포함됨) Cloudflare - Workerd (https://github.com/cloudflare/workerd) V8 엔진 기반, Webassembly, Web Platform API 호환성 제공 제공 V8 Isolation 기능을 이용한 샌드박싱 환경을 제공이 특징 - 하나의 Runtime에서 여러개의 App을 수행할 수있는 독립적 공간을 제공 VM 또는 Container 대비 사용 Cold Start 시간, CPU 사용시간 및 사용 메모리 절감 그 밖의 Server&#x2F;Edge JavaScript Runtime Alibaba Cloud - EdgeRoutine Vercel - Edge Runtime Fastly - Compute@Edge Lagon - Lagon Runtime JavaScript Runtime 간 상호 운용성 Node.js로 시작된 Server&#x2F;Edge 향 Runtime이 다양한 형태로 파편화 되면서 개발자는 Unified App을 개발이 어려워졌다. 이로 인해 여러 Runtime 구분없이 공통으로 사용할 수 있는 API 제공에 대한 필요성이 제기되었다. 이식성 높은 코드를 작성에 대한 각 서버쪽 JS Runtime의 사용자 피드백에 따르면 공통 API에 디자인에 대해 Web-first 접근법이 매우 중요하다는 결과가 있었다. Web 플랫폼이란 가장 크고 중요한 API와 지식에 바탕을 두면 특정 플랫폼이나 Runtime별 새로운 API나 기능을 배우지 않고 보다 보편적으로 통용되는 API를 사용할 수 있다고 판단되었기 때문이다. 한편, Web Platform API가 브라우저의 특정 요구사항만을 고려해 설계되어있어 브라우저가 아닌 환경에 쉽게 최적화가 어렵거나 동작이 미세하게 다른 점이 있었다. 이러한 차이들이 발견됨에 따라 일관성있는 API 를 동작을 구현하기 어렵게 되었다. 이러한 문제를 해결하기 위해, Node.js, Deno, Cloudflare, Vercel, Shopify등에서 활동하는 엔지니어 주축으로 2022년 Web-interoperable Runtimes Community Group (WinterCG) 가 조직되었다. 브라우저를 포함한 JavaScript Runtime의 구현이 어떻게 다르며 상호 운영성을 높이기 위한 부분을 토론하고 WHATWG, W3C에 필요한 부분을 제안하고 있다. 현재 JavaScript 런타임 환경에서 지원을 권장하는 최소 API 집합이 제안되어 있다. WinterCG에 순응한 JavaScript를 만들시, 이러한 Web Platform API 기반으로 App을 구성하면 브라우저, Server, Edge환경의 구별없이 JavaScript 런타임 간 Portability를 보장받게 된다. InsightNode.js의 성숙도와 생태계 규모는 여전히 큰 장점이다. 그러나, Node.js가 JavaScript를 브라우저 외부로 가져온 것과 같이, 모던 웹 기술을 Server 또는 Edge 기기 향 JavaScript 런타임에 이식해 생태계를 구축하려는 동향이 있다. 이러한 흐름을 반영해 개발자를 지원하고 기기에 최적화된 JavaScript 런타임 제공을 고려해볼 수 있을 것이다.","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"structuredClone in native","slug":"article-2023-10-28-structure-clone-native","date":"2023-10-27T15:13:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-10-28-structure-clone-native/","link":"","permalink":"https://llnm.github.io/article/2023-10-28-structure-clone-native/","excerpt":"","text":"structuredClone은 객체를 deep copy 하는 API 이다. 만약 structuredClone 가 Node.js의 JavaScript 영역에 구현되어있다면 Native 영역으로 구현부를 이동시킬때 유의미한 성능향상이 있을 것이다. src: implement structuredClone 은 그런면에서 흥미로운 내용일 것이라 생각하고 리뷰해보았다. 기존 구현Web Platform API인 structuredClone은 원래 global 영역에 노출되어있지 않은 API였다. Deep Copy를 JavaScript 에서 제공하지 않지만, Web Spec. 인 MessageChannel 이나 IndexedDB 같은 기능을 위해선 Object의 직렬화&#x2F;역직렬화 기능은 필요할 수 밖에 없었다. 예를들어 Web Worker에서 한 Thread에서 다른 Thread로 전달하는 것은 서로 다른 JavaScript Context로 데이터를 넘기는 일이기 때문에 Deep Copy 기능이 필요하다. Node.js 에는 structuredClone API 앞서 MessageChannel이 구현되어 있었는데 이를 활용한 hack 을 이용하면 structuredClone의 결과와 같은 Deep Copy를 구현할 수 있었다. 그래서 기존에는 아래와 같은 방식으로 구현되었었다. structured_clone.jslink13141516171819202122232425function structuredClone(value, options = undefined) &#123; if (arguments.length === 0) &#123; throw new ERR_MISSING_ARGS(&#x27;value&#x27;); &#125; // TODO: Improve this with a more efficient solution that avoids // instantiating a MessageChannel channel ??= new MessageChannel(); channel.port1.unref(); channel.port2.unref(); channel.port1.postMessage(value, options?.transfer); return receiveMessageOnPort(channel.port2).message;&#125; 아이디어는 MessageChannel의 인스턴스를 생성하고 해당 channel로 데이터를 전달함으로서 그 과정에서 수행되는 structuredCloned 을 이용하는 것이다. MessageChannel 내부MessageChannel::postMessage(value[,&#123; transfer &#125;]) 내부 구현에서 structuredClone의 구현은 아래와 같은 두개의 Step을 통해 구현된다. Step 1. clone 하거나 transfer 해야할 객체를 리스트업 한다. Step 2. 직렬화&#x2F;역직렬화 과정을 수행한다. 기존 구현의 TODO로 기술되어있듯이 원 저자 역시 structuredClone을 위해 MessageChannel을 사용하는 것이 그렇게 효율적인 방법은 아니라는 것을 기술해 두었다. PR Author는 MessageChannel::postMessage()에서 상기 Step 1 동작을 수행하는 부분을 직접 JavaScript 영역에서 호출하면 MessageChannel을 이용하지 않을 수 있을 것이라 생각했다. 현재 코드 상에서 큰 리팩토링을 우려했지만 생각보다는 적은 수고로 가능한 내용이었다. As-Is: structuredClone (JS) ... (1) new MessageChannel MessageChannel::postMessage (C++) ... (2) MessageChannel 구현 Step 1 Step 2 ... (3) 위는 기존 구현부를 단순화한 내용이다. PR의 아이디어는 MessageChannel 와 관련된 위의 (1), (2), (3) 해당하는 부분을 제거한다. Step 1에 해당하는 부분을 MessageChannel 와 공유하고 Step 2 구현을 구현하여 structuredClone의 구현체를 단순화 시키는 내용이다. Step 1transfer를 해야할 객체의 리스트업을 다음 함수 GetTransferList로 분리한 뒤 새로 native side에서 구현한 structuredClone과 기존 MessageChannel::postMessage()에서 공동으로 사용하도록 한다. 123456bool GetTransferList(Environment* env, Local&lt;Context&gt; context, Local&lt;Value&gt; transfer_list_v, TransferList* transfer_list_out) &#123; ... &#125; Step 2이후 직렬화&#x2F;역직렬화를 수행해 clone을 수행한다. To-Be: structuredClone (JS) internalBinding(&#39;messaging&#39;).structuredClone (C++) Step 1 Step 2 123456789101112131415Local&lt;Value&gt; value = args[0];TransferList transfer_list;...// step 1GetTransferList(env, context, transfer_list_v, &amp;transfer_list)...// step 2Local&lt;Value&gt; result;if (msg-&gt;Serialize(env, context, value, transfer_list, Local&lt;Object&gt;()) .IsNothing() || !msg-&gt;Deserialize(env, context, nullptr).ToLocal(&amp;result)) &#123; return;&#125; Step 3직렬화&#x2F;역질화 의 내부 알고리즘은 V8 내부에서 수행하며, src/node_messaging.cc 에는 Node.js에서 정의한 객체에 대한 clonning을 어떻게 할지가 정의되어 있다. 성능의 향상?이 PR의 제목만 보면 JavaScript side에서 수행하는 Cloning을 native side로 이동시키면서 상당한 성능의 향상이 있을 것이란 생각이 들었다. 그러나 실제로는 MessageChannel의 instance 를 생성하는 부하만 줄이는 것이며 실제로 Cloning되는 메카니즘은 그대로이다. 그래서 structuredClone 자체의 성능은 더 개선할 내용이 있는 것이다. GetTransferList 안은 ReadIterable이 구현되어있으며 transfer 목록을 순회하기 위해 iterator를 호출한다. 이 과정에서 JavaScript Side와 Native Side간 Context Switching 이 일어나 속도가 저하된다. 이 부분은 여전히 TODO로 남겨졌다. 123456789101112131415161718192021static Maybe&lt;bool&gt; ReadIterable(Environment* env, Local&lt;Context&gt; context, // NOLINTNEXTLINE(runtime/references) TransferList&amp; transfer_list, Local&lt;Value&gt; object) &#123; if (!object-&gt;IsObject()) return Just(false); .... std::vector&lt;Local&lt;Value&gt;&gt; entries; while (env-&gt;can_call_into_js()) &#123; Local&lt;Value&gt; result; // 이곳의 while 문에서 C++ -&gt; JavaScript 호출이 되며 성능 저하가 일어난다. if (!next.As&lt;Function&gt;()-&gt;Call(context, iterator, 0, nullptr) .ToLocal(&amp;result)) return Nothing&lt;bool&gt;(); transfer_list.AllocateSufficientStorage(entries.size()); std::copy(entries.begin(), entries.end(), &amp;transfer_list[0]); return Just(true);&#125; 결과structuredClone을 위해 MessageChannel instance가 생성되는 시간을 줄이고 기존에 JavaScript side에서 구현되어 snapshot에 포함되지 못했던 structuredClone 기능을 snapshot에 포함할 수 있었던 것이 해당 PR의 의미라고 할 수 있다. 12// snapshot 생성시 포함되도록 등록registry-&gt;Register(StructuredClone); 한가지 의문은 Web Spec.에 의하면 trasfer 는 An array of transferable objects that will be moved rather than cloned to the returned object. 이라고 정의 되어있는데 왜 iterable로서 순회해야하는지는 의문이다. Array 객체로서 순회하는 것은 V8 API로 존재하고 있기 때문에 iteratable interface에 따라 next() 호출을 해주지 않아도 구현이 가능할 것 같은데 말이다. 아무튼, iterable로 처리되야한다면 상기 언급했던 Step 1를 JavaScript 쪽에서 목록을 만들고 C++ 로 넘길 수 있으면 TODO로 남겨진 성능 저하를 개선 할 수 있을 것이라 생각된다. 관련 컨텐츠 Iteration protocols structureClone 참고 https://github.com/nodejs/node/pull/50330","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"structureClone","slug":"article-2023-10-14-structure-clone","date":"2023-10-13T07:43:45.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-10-14-structure-clone/","link":"","permalink":"https://llnm.github.io/article/2023-10-14-structure-clone/","excerpt":"","text":"JavaScript에서 값을 복사할때는 항상 얕은 복사 (shallow copy)를 수행한다. 따라서 primitive data type (string, number, bigint, boolean, undefined, symbol등) 이 아닌 경우 객체의 참조로 처리된다. 얕은 복사의 반대는 깊은 복사 (deep copy)인데, 이는 복사 중 다른 객체를 참조를 찾으면 재귀적으로 참조의 내용도 찾아 복사를 수행한다. 이렇게 참조가 있는 한 객체를 깊은 복사하는 것은 꽤 까다로운 일이다. 결과물인 복사된 객체에서 원본이 가르키는 어떤 참조도 중첩하여 갖게해서는 안되기 때문이다. JavaScript에서는 이러한 깊은 복사를 수행하는 제공되지 않는다. 그래서, 오랜동안 JSON.stringify/parse 를 이용한 일종의 트릭을 이용한 깊은 복사 방법을 제공하는 라이브러리에 의존해왔다. 그러나 Web Platform에서는 IndexedDB 저장이나, WebWorker간 MessageChannel 메세지 전송등의 Spec.을 구현하고자 할때 JavaScript 직렬화&#x2F;역직렬화 방법이 필요하였다. 이를 구현한 것이 structuredClone이며, 함수 내부적으로 복사를 어떻게 수행하는지는 structured clone algorithm이라고 부르는 Spec.에 의해 정의되어있다. 모든 타입의 JavaScript 객체가 이 알고리즘에 의해 처리되는 것은 아니며, JavaScript 의 Builtin Type뿐 아니라 Web Spec. 정의된 일부 객체들도 복사가 가능하도록 되어있다. APIAPI의 사용 방법은 아래와 같은데, 두번째 파라미터가 정의되었을 때의 동작이 눈여겨 볼만하다. 12structuredClone(value);structuredClone(value, options); 첫번째 파라미터는 structured clone algorithm이 지원하는 타입의 복사본을 만든다. 2번째 파라미터 optional 한 option 값인데 현재 options.transfer : Array 를 지원한다. 이 옵션을 통해 전달되는 값은 Transferable objects의 배열이 가능하며, Transferable objects의 대표적인 타입으로는 ArrayBuffer, Readable&#x2F;WritableStream등이 있다. 복사가 아닌 transfer를 이용할 때의 장점은 두가지를 들 수 있다. 소유권의 이전 - transfer 되는 리소스를 하나의 JavaScript Context에서만 사용할 수 있게 소유권을 제한할 수 있다. 성능 - transfer 객체와 환경에 따라 zero-copy operation을 이용하여 빠르게 다른 context로 넘길 수 있다. 이는 특히 WebWorker와 같이 한 thread에서 다른 thread로 데이터를 넘길때 유용하다. 12345678const buffer1 = new ArrayBuffer(16);const object1 = &#123; buffer: buffer1,&#125;;const object2 = structuredClone(object1, &#123; transfer: [buffer1] &#125;);// Creating an array from the original buffer throws a TypeErrorconst int32View1 = new Int32Array(object1.buffer); 1234const object1 = &#123; amanita: [&#x27;muscaria&#x27;, &#x27;virosa&#x27;],&#125;;const object2 = structuredClone(object1); // cloned 참고 https://www.proposals.es/proposals/Structured%20Clone https://developer.mozilla.org/en-US/docs/Web/API/structuredClone","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Iteration protocols","slug":"article-2023-10-11-iteration-protocols","date":"2023-10-10T10:47:12.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-10-11-iteration-protocols/","link":"","permalink":"https://llnm.github.io/article/2023-10-11-iteration-protocols/","excerpt":"","text":"어떤 객체가 String, Array 같이 순회 (iteration) 할 수 있는 타입이 아니더라도, JavaScript에서 순회가 가능한 (iterable) 객체로 만드는 방법이 있다. 이를 Iteration protocol 이라하며 interable, iterator 를 만드는 2개의 규칙(protocol) 을 기술하고 있다. iterable 규약에 순응하는 객체는 for...of syntax, Spread syntax, destructuring syntax 등에서 사용이 가능해진다. 1. iterable 정의iterable로 정의하기 위해서는 아래와 같은 내용을 객체 또는 prototype chain내 객체에서 아래 내용을 구현하여야 한다. [Symbol.iterator] (혹은 @@iterator) 란 Property로 메소드를 구현해야한다. 해당 메서드는 iterator 객체를 반환하여야 한다. 2. iterator 정의iterable 에서 [Symbol.iterator] 호출에 의해 반환되는 iterator 순회할 때 마다 결과를 반환한다. 결과를 반환하기 위해 iterator은 아래의 프로퍼티를 구현한다. next 란 이름의 메소드 구현 (필수) next 메소드는 1개 혹은 0개의 파라미터를 전달 받을 수 있으며, IteratorResult 인터페이스를 준수하는 객체를 반환한다. 반환값이 undefined의 경우 &#123; done: false, value: undefined&#125; 와 동일 return(value), throw(exception) 메소드 구현 (옵션) return() : IteratorResult 인터페이스를 준수하는 객체를 반환한다. 이후 next 메소드는 더 호출되지 않는다. throw() IteratorResult 인터페이스를 준수하는 객체를 반환한다. 필요한 경우 이 메소드르 호출하여 iterator에게 오류가 감지되었음을 알린다. 2.1 IteratorResult Interface done : true&#x2F;false로 반복이 끝났는지를 나타낸다. 끝났으면 true로 설정 value : 현재 반환되는 값을 설정 예시iterable 구현 일반1234567891011let i = 0;const iterable = &#123; [Symbol.iterator]() &#123; return this; &#125;, // i next() &#123; return i &gt; 3 ? &#123; done: true &#125; : &#123; value: i++, done: false &#125;; &#125;,&#125;;for (let n of iterable) console.log(n); // 0, 1, 2, 3 iterable 의 return() 구현1234567891011121314151617181920212223242526272829const customIterator = &#123; currentIndex: 0, [Symbol.iterator]() &#123; return this; &#125;, next() &#123; this.currentIndex++; if (this.currentIndex &lt;= 5) &#123; return &#123; done: false, value: this.currentIndex &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125;, return() &#123; console.log(&#x27;Closing the iterator.&#x27;); // 여기서 리소스 정리 또는 마무리 작업을 수행 return &#123; done: true &#125;; &#125;,&#125;;for (const num of customIterator) &#123; console.log(num); if (num === 3) &#123; break; // 이터레이션을 중단. 이때 return() 메서드가 호출되고 이터레이션을 종료 &#125;&#125; Node.js 의 /lib/events.js 에서 구현 (실 활용 예제)iterator의 return() 함수를 정의하여 리소스를 해제하는데 사용한다. events.jslink110311041105return() &#123; return closeHandler();&#125;, iteration 도중 오류를 핸들링하기 위해 throw(err) 함수를 정의한다. events.jslink1107110811091110111111121113throw(err) &#123; if (!err || !(err instanceof Error)) &#123; throw new ERR_INVALID_ARG_TYPE(&#x27;EventEmitter.AsyncIterator&#x27;, &#x27;Error&#x27;, err); &#125; errorHandler(err);&#125;, iteration을 위한 next() 호출이 될때 IteratorResult 형식으로 현재 값을 반환한다. events.jslink1071107210731074107510761077107810791080108110821083const iterator = ObjectSetPrototypeOf(&#123; next() &#123; // First, we consume all unread events if (size) &#123; const value = unconsumedEvents.shift(); size--; if (paused &amp;&amp; size &lt; lowWatermark) &#123; emitter.resume(); paused = false; &#125; return PromiseResolve(createIterResult(value, false)); &#125; next() 호출에 대해 undefined를 반환함으로써 iteration이 종료되었음을 알린다. events.jslink109410951096// If the iterator is finished, resolve to doneif (finished) return closeHandler(); 출처 https://tc39.es/ecma262/multipage/control-abstraction-objects.html#sec-iteration https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#the_iterator_protocol","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"자바스크립트 컨테이너","slug":"article-2023-09-12-js-container","date":"2023-09-11T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-09-12-js-container/","link":"","permalink":"https://llnm.github.io/article/2023-09-12-js-container/","excerpt":"","text":"컨테이너는 응용 프로그램과 그 실행 환경을 패키징하고 격리하는 데 사용되는 기술이다. 배포되는 서비스 소프트웨어의 운영체제 수준을 가상화하고, 응용 프로그램 및 시스템 종속성을 포함한 모든 것이 포함된 독립적인 환경을 제공한다. 이런 리눅스 컨테이너보다는 좀 더 높은 추상화 레벨이긴 하지만 유사한 형태의 격리환경은 브라우저의 JavaScript 환경이다. 그리고, 서버 소프트웨어를 위한 새로운 상위 레벨 컨테이너로서 JavaScript를 이용하는 방식이 떠오르고 있다. JavaScript 컨테이너JavaScript 컨테이너란 서버 소프트웨어 배포를 위한 새로운 상위 레벨 컨테이너로, 리눅스 컨테이너와는 다른 영역의 문제를 해결하기 위한 것이다. 이 컨테이너는 단순함, 브라우저와의 호환성, 웹어셈블리와의 연동 등의 특징을 가지고 있다. 보안보안 측면에서 컨테이너는 독립된 메모리 공간을 가지고 있으며 한 컨테이너가 다른 컨테이너의 메모리 공간을 직접적으로 접근하는 것은 제한된다. 이것은 브라우저의 탭(Tab) 에서 제공하는 샌드박싱 (Sandboxing)을 제공하는 것과 비슷하다. 브라우저 샌드박싱은 웹 애플리케이션을 샌드박스내 격리된 환경에서 실행함으로서 악의적인 코드나 공격으로부터 웹 애플리케이션 및 사용자 시스템을 보호한다. 메모리 격리 (Memory Isolation)모던 브라우저는 대부분 프로세스(Process) 단위로 브라우징 세션을 격리하는 샌드박스 환경을 제공한다. 브라우저의 윈도우나 탭은 이렇게 별도 프로세스가 할당된다. 이에 비해 JavaScript 런타임은 프로세스가 단위 아닌, JavaScript 엔진에서 제공하는 보안 매커니즘을 통해 격리 환경을 제공한다. 예를 들어 V8의 Isolation 기능은 JavaScript VM (Virtual Machine) 단위로 할당이 되어야하며, VM간 직접적인 메모리의 접근은 불가하다. 권한 모델 (Permission Model)기존의 JavaScript 런타임은 사용자 자원 사용에 대한 특별한 제한을 두지 않았다. 실행 권한이란 것을 JavaScript 런타임에서 제어하는 복잡성 대신 사용자에게 런타임 실행환경을 안전하게 하는 책임을 넘긴 것이다. 따라서, SMACK(Simplified Mandatory Access Control Kernel) 통한 보안 통제를 하던지, Docker Container 와 같은 격리 환경을 만드는 것은 사용자의 책임이었다. JavaScript 컨테이너는 자체적으로 권한 모델을 사용하여 애플리케이션의 요청 제한한다. 기본적으로 &quot;최소 권한&quot; 원칙을 따르는데, 각 구동을 위한 필요한 권한만을 부여하고, 다른 권한은 차단하는 것을 기본으로 한다. 예를 들어, File System이나 Network 기능을 액세스하기 위해서는 사용자의 명시적인 동의가 필요하다. 성능서버리스 플랫폼 서비스들이 SaaS 의 경우 리눅스 컨테이너나 프로세스를 사용하여 실행 환경을 가동한다. 이는 자체 머신에서 JavaScript 런타임을 실행하는 것보다 가벼운 환경에서 코드를 실행하지 않는다. 서버리스 플랫폼은 프로세스를 확장하는 방식으로 환경 구성을 준비하기 때문에 Cold Start가 발생한다. 이런 경우 JavaScript 환경에서 제공하는 격리 환경을 이용하면 단일 프로세스가 여러개의 격리환경을 사용할 수 있다. 즉, Cold Start로 인한 지연을 줄이는 한편, 프로세스에 추가되는 메모리 리소스의 사용도 개선된다. 또한, 프로세스 기반으로 여러개의 서비스가 실행되어 있을시, 다양한 프로세스간에 전환에 필요한 시간이 걸리게된다. 예를 들어 한 프로세스에 필요한 메모리를 내보내고, 다른 프로세스를 위한 메모리를 로드하는 등의 컨텍스트 스위치(Context Switch)가 발생한다.이는 프로세스의 갯수에 비례해 오버헤드가 발생하는데, JavaScript내 격리 환경을 이용해 애플리케이션을 구성하면 프로세스간 전환에 따른 오버헤드를 없앨 수 있다. 단점이러한 시스템은 임의의 컴파일된 코드를 실행할 수 없으며, Javascript나 WebAssembly가 지원하는 언어로 작성되어야한다. References https://blog.cloudflare.com/cloud-computing-without-containers/ http://runtimejs.org/jsconf/#/17","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://llnm.github.io/tags/node-js/"}]},{"title":"Node.js 프로젝트 개요 1","slug":"article-2023-09-03-nodejs-overview-1","date":"2023-09-03T02:34:04.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-09-03-nodejs-overview-1/","link":"","permalink":"https://llnm.github.io/article/2023-09-03-nodejs-overview-1/","excerpt":"","text":"본 문서는 그동안의 Node.js 기여 경험을 바탕으로 Node.js 프로젝트를 처음 시작하는 사람들을 위해 간략한 개요를 전달하고자 한다. 물론 프로젝트 내용은 지속적으로 변경되고 있으며 현 시점에서 유효한 내용이다. 그러나 어느 정도 견고하게 확정되어 오랫동안 통용되고 있는 내용에 대해 작성하고자 한다. Node.js Core의 용어Node.js 에서의 각 요소를 가르키는 용어는 여러가지로 통용이 되어왔으나 아래와 같이 공식적으로 정리되었다. Built-in(s): Node.js 는 JavaScript 부분과 C++ 부분으로 이루어져 있다. Node core를 이루는 기본적으로 JavaScript 코드를 Builtins 혹은 Builtin module 이라고 부른다. Bindings: Builtins 에서 사용하는 API 로서 Native 쪽에서 실행되는 부분을 뜻한다. Native 코드는 C++로 이루어져 있다. C++ 코드가 직접적으로 사용자 영역으로 노출되는 경우는 없으며 JavaScript 부분에서 사용자 인터페이스를 거쳐서 사용된다. 일반적으로 JavaScript 부분은 사용자 인터페이스를 노출하고 Bindings를 부르기 전에 입력된 Arguments에 대한 Validation을 처리한다. C++ 코드내에서는 별도의 Validation은 수행하지 않고 정해진 Arguments가 들어왔는지에 대해서 Assertion을 수행한다. addons: Node.js 에 동적으로 링크되는 Shared library로 Node-API, NAN 를 통해 구성되고 API를 제공한다. 프로젝트 소스 구성lib lib - JavaScript builtins 에 해당하는 코드가 포함된다. lib/**/*.js 하위의 코드이다. 모든 모듈은 외부 인터페이스 영역과 internals 영역으로 나뉜다. 이러한 구분을 통하여 internal 영역의 코드가 사용자에게 노출되어 변조되는 것을 방지한다. internal&#x2F;bootstrap과 internal&#x2F;main 은 Node.js 의 Builtins를 Bootstrap하는 코드와 옵션별 Entry 코드를 포함하고 있다. src src - C++ 영역에서 구현된 src/node_*.cc 의 이름으로 된 bindings 코드와 node_api.h 파일에 정의된 addons (Node-API)지원 인터페이스 코드를 제공한다. node_main.cc는 Node.js 의 프로그램 Entry 이며, 각 JavaScript Context 별로 생성된 환경정보는 env.cc 의 코드에서 정의된 Environment 클래스에 의해 다룬다. deps deps - Node.js 가 사용하고 있는 외부 Dependency들을 다룬다. v8, libuv, http_parser, zlib, openssl 등이 있다. git submodule이나 subtree로 다루지 않고 직접 코드를 copy하여 사용한다. 빌드를 위해 각 프로젝트의 build config를 직접 부르지 않고 gyp로 구성한 build config 를 각각에 추가해 프로젝트 root의 node.gyp로 부터 읽는다. dependency가 업데이트 할때 버전 정보를 별도의 header로 관리하도록 되어있다. (src/*_version.h 파일) 이를 통해 Node.js 에서 각 dependency의 정보를 확인할 수 있게 한다. 업데이트 스크립트는 tools/dep_updaters/update-*.sh 에서 확인할 수 있다. test test - Node Core에 대한 Test를 다룬다. test/parallel 내 테스트 코드가 주로 사용되는데, 병렬로 실행되어도 서로 영향을 미치지 않은 코드를 담고 있다. 이에비해 test/sequential은 순차적으로 실행되어야하는 테스트를 다룬다. test/cctest는 gtest로 구성하여 Node.js embedder를 위한 테스트 코드, test/addons 은 Node-API에 대한 테스트를 포함한다. test/wpt는 Node.js의 Web 호환성 테스트를 위해 구성되어있는데, Web Platform Test의 특정 버전을 가져와 사용한다. wpt 버전을 업데이트하기 위한 tool과 Node.js에서 WPT test harness가 동작하기 위한 환경 설정을 한다. test/common: 해당 폴더는 Node.js test 구성을 위한 툴을 다루고 있다. 해당 툴의 사용은 선택적인것이 아니고 반드시 모든 테스트가 test/common/index.js를 호출해줘야한다. 각 테스트를 Node.js 런타임으로 직접 실행할 수도 있지만 기본적으로 Worker Thread에서 동작하도록 되어있다. 런타임 실행시 특별한 CLI option이 전달되야할 때는 Flags 커멘트 라인을 테스트 코드 첫줄에 작성하여 전달할 수 있도록 한다. 1// Flags: --no-warnings --expose-gc --expose-internals benchmark benchmark - 연산성능을 측정하기 위한 코드를 다루고 있다. compare.js 는 비교하고자 하는 두개의 executable을 파라미터로 받으며, local build 버전과 global에 설치된 특정 Node.js 버전을 전달함으로서 하나의 코드상에서 어떤 성능 변화가 있는지 확인 가능하다. 벤치마크 수행결과 읽는 방법벤치마크에서의 성능차이는 실제 변경 사항 자체보다 각 환경에 따라 발생하는 임의의 변수들로 인해 달라질 수 있다. 그렇기 때문에 수행결과의 신뢰성 나타내는 지표를 확인할 필요가 있다. 1234567891011 confidence improvement accuracy (*) (**) (***)util/priority-queue.js n=100000 -2.50 % ±4.41% ±5.87% ±7.64%fs/bench-writeSync.js n=100000 *** 116.41 % ±9.35% ±12.49% ±16.36%fs/bench-readSync.js n=100000 type=1 0.46 % ±6.13% ±8.16% ±10.62%Be aware that when doing many comparisons the risk of a false-positiveresult increases. In this case, there are 1 comparisons, you can thusexpect the following amount of false-positive results: 0.05 false positives, when considering a 5% risk acceptance (*, **, ***), 0.01 false positives, when considering a 1% risk acceptance (**, ***), 0.00 false positives, when considering a 0.1% risk acceptance (***) 벤치마크를 수행하면 위와 같은 결과를 확인 할 수 있다. 이때 먼저 확인해야 할 것은 confidence다. confidence에 별표 (*, **, ***) 가 없는 모든 줄은 무시한다. util/priority-queue.js 케이스를 해석하면 -2.50%-4.41%와 -2.50%+4.41% 사이라고 가정할 수 있으며, 해당 내용은 5%의 확률로 틀린 결과 (False Positives) 일 수 있다는 뜻이다. Node.js 에서는 일반적으로 별표가 2개 혹은 3개 정도의 risk 허용범위에 있을때 개선, 퇴보 여부를 신뢰할 수 있는 데이터라고 생각하고 있다. typings typings - Node.js 코드 작성시 Type을 확인할 수 있게 하는 용도로 작성된 *.d.ts 파일을 포함한다. JavaScript 자체는 타입정보를 제공하지 않지만 이곳의 파일들이 lib 폴더내 모듈의 외부 인터페이스 파일들과 매칭된다. vscode 와 같은 툴에서 개발시 타입을 확인 할 수 있고 code complition과 같은 기능을 제공할 수 있다. doc doc - API 도큐먼트를 빌드하기 위한 원본 md파일과 Node.js에 기여를 할 때 알아야 할 여러 정보를 확인 할 수 있다. API 도큐먼트 빌드를 목적으로 하기 때문에 따라야할 convention이 존재하며 수정 후 $ make format-md 혹은 $ tools/lint-md/lint-md.mjs 이용해 lint 가능하다. API 도큐먼트의 API는 알파벳 순으로 작성되야하며 내부&#x2F;외부 링크는 md에 직접 작성하지 않고 문서의 최하단에 주석으로 작성되야한다. Node.js의 CLI Option이 수정되면 doc/node.1 의 파일을 업데이트 한다. 그렇게 함으로서 Unix 계열의 운영체제에서 man 유틸을 통해 명령어 문서에 접근할 수 있도록 한다.","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Node.js V8 Options","slug":"article-2023-08-21-v8-options","date":"2023-08-21T05:09:42.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-08-21-v8-options/","link":"","permalink":"https://llnm.github.io/article/2023-08-21-v8-options/","excerpt":"","text":"Node.js V8 Build Option Node.js는 기본적으로 JavaScript Runtime이다. JavaScript Runtime은 JavaScript를 실행시킬수 있는 환경을 뜻하며 코드를 해석하고 실행하는 핵심 역할을 담당한다. Node.js 에서 여러 JavaScript 엔진중에서 구글이 개발한 V8 엔진을 사용하고 있는데, Node.js 빌드시 V8 Option을 전달하여 Customization 할 수 있다. V8 Option은 Node.js Core코드와 직접적으로 연관이 있는 제어 코드 외 deps/v8 에서 library 빌드 시 전달할 수 있는 옵션으로 나뉜다. Node.js OptionsLite ModeV8은 메모리 사용량 보다 성능 기본적으로 초점을 맞추고 있다. 그러한 개발 방향과 다소 반대의 상황에서 사용할 수 있는 옵션으로 기본적인 메모리 사용량을 줄이고 JIT (Just-In-Time) 컴파일을 꺼서 메모리 소비를 더욱 줄인다. JIT(Just-In-Time) 컴파일은 프로그램을 실행하는 동안 실제로 필요한 코드 부분만 컴파일하는 기술이다. 일반적으로 JavaScript 코드는 한 줄씩 인터프리터에 의해 해석되지만, JIT 컴파일러는 자주 사용되는 함수나 루프 같은 핵심 코드를 미리 컴파일하고 최적화하여 실행 속도를 높인다. 관련 Configuration configure.pylink789790791792793794795parser.add_argument(&#x27;--v8-lite-mode&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;v8_lite_mode&#x27;, default=False, help=&#x27;compile V8 in lite mode for constrained environments (lowers V8 &#x27;+ &#x27;memory footprint, but also implies no just-in-time compilation &#x27; + &#x27;support, thus much slower execution)&#x27;) https://v8.dev/blog/v8-lite CodeCache 기능JavaScript 엔진은 CodeCache 기능을 제공한다. CodeCache는 컴파일된 코드를 캐시로 저장하는 공간이며, 반복적으로 사용되는 코드를 저장해두어 빠른 실행을 가능하게 한다. 이는 웹 애플리케이션의 성능을 향상시키는 데 도움이 된다. 관련 Configuration configure.pylink626627628629630parser.add_argument(&#x27;--without-node-code-cache&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;without_node_code_cache&#x27;, default=None, help=&#x27;Turn off V8 Code cache integration.&#x27;) SnapshotSnapshot은 초기 런타임 상태를 저장하고, 이를 나중에 다시 불러와 재사용할 수 있게 해준다. 이로써 애플리케이션의 시작 시간을 단축시키고 초기 로딩 시간을 최적화할 수 있다. 관련 Configuration configure.pylink612613614615616617618619620621622623624parser.add_argument(&#x27;--write-snapshot-as-array-literals&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;write_snapshot_as_array_literals&#x27;, default=None, help=&#x27;Write the snapshot data as array literals for readability.&#x27; &#x27;By default the snapshot data may be written as string literals on some &#x27; &#x27;platforms to speed up compilation.&#x27;)parser.add_argument(&#x27;--without-node-snapshot&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;without_node_snapshot&#x27;, default=None, help=&#x27;Turn off V8 snapshot integration. Currently experimental.&#x27;) configure.pylink823824825826827parser.add_argument(&#x27;--v8-enable-snapshot-compression&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;v8_enable_snapshot_compression&#x27;, default=None, help=&#x27;Enable the built-in snapshot compression in V8.&#x27;) Pointer CompressionV8 엔진이 JavaScript 객체에 대한 포인터를 저장할 때 사용되는 메모리를 줄이기 위한 최적화 기능이다. 기본적으로 V8는 64비트 포인터를 사용하여 객체를 가리키지만, Pointer Compression을 활성화하면 객체 포인터를 더 작은 크기 (32비트)의 포인터로 압축하여 메모리를 절약할 수 있다. 작은 포인터 크기는 환경에 따라서 CPU 캐시에서 객체를 로드하는 데 더 효율적일 수 있으며, 이로 인해 더 빠른 실행 속도를 얻을 수도 있다. 다만 이 옵션을 크면 주소공간이 4GB로 제한되며 따라서 max heap 크기도 그 크기로 한정된다. 관련 Configuration configure.pylink488489490491492parser.add_argument(&#x27;--experimental-enable-pointer-compression&#x27;, action=&#x27;store_true&#x27;, dest=&#x27;enable_pointer_compression&#x27;, default=None, help=&#x27;[Experimental] Enable V8 pointer compression (limits max heap to 4GB and breaks ABI compatibility)&#x27;) Runtime V8 OptionsNode.js 실행시점에도 V8 동작에 관한 세부 설정을 할 수 있는데 이러한 옵션을 빌드 시점에 default로 적용할 수 도 있다. 전체옵션을 보고싶다면 아래와 같이 실행하면 된다. 1node --v8-options 관련 Configuration configure.pylink500501502503parser.add_argument(&#x27;--v8-options&#x27;, action=&#x27;store&#x27;, dest=&#x27;v8_options&#x27;, help=&#x27;v8 options to pass, see `node --v8-options` for examples.&#x27;) References https://v8.dev/blog/improved-code-caching https://www.geeksforgeeks.org/what-is-the-relationship-between-node-js-and-v8/ https://joyeecheung.github.io/blog/2022/04/14/fixing-snapshot-support-of-class-fields-in-v8/","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"V8 Fast API에 대하여 2","slug":"article-2023-08-14-fast-api-2","date":"2023-08-13T15:30:20.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-08-14-fast-api-2/","link":"","permalink":"https://llnm.github.io/article/2023-08-14-fast-api-2/","excerpt":"","text":"V8 Fast API 사용이전 Post에 이어 본 페이지에서는 V8 Fast API 를 코드 상에서 어떻게 사용하는 확인하고 어떻게 기존 API와 다른지 확인해본다. 1. Add functions for Fast APISlow API의 경우 FunctionCallbackInfo를 인자로 받는것에 비해 Fast API는 입력값 자체를 파라미터로 받는다. 12345678910static double FastDivide(const int32_t a, const int32_t b, v8::FastApiCallbackOptions&amp; options) &#123; if (b == 0) &#123; options.fallback = true; return 0; &#125; else &#123; return a / b; &#125;&#125; 2. Fallback Slow APIFallback API는 사용자 지정 오류를 발생시키거나 자바스크립트 코드를 실행해야 할 때와 같이 느린 경로로 전환하는 것이 바람직한 경우에 대비해 폴백을 지원한다. Fallback 메커니즘은 Fast API 함수 선언의 C++ 구현에서 활성화 및 변경할 수 있는데, V8에서 FastApiCallbackOptions 을 true로 전달한다. 123456789101112131415static void SlowDivide(const FunctionCallbackInfo&lt;Value&gt;&amp; args) &#123; Environment* env = Environment::GetCurrent(args); CHECK_GE(args.Length(), 2); CHECK(args[0]-&gt;IsInt32()); CHECK(args[1]-&gt;IsInt32()); auto a = args[0].As&lt;v8::Int32&gt;(); auto b = args[1].As&lt;v8::Int32&gt;(); if (b-&gt;Value() == 0) &#123; return node::THROW_ERR_INVALID_STATE(env, &quot;Error&quot;); &#125; double result = a-&gt;Value() / b-&gt;Value(); args.GetReturnValue().Set(v8::Number::New(env-&gt;isolate(), result));&#125; 이렇게 지정된 API는 아래와 같이 JavaScript를 실행했을때 각각 Fast, Slow Path를 따라 실행하게 된다. 12divide(2, 2); // calls fast pathdivide(2, 0); // calls fallback (slow path) 기존에, SetMethod 나 SetMethodNoSideEffect 를 통해 객체에 binding API를 등록했던것과 다르게 SetFastMethod 를 이용하여 Fast API를 등록한다. 4번째 인자로 Fallback API를 전달한다. 12345678910CFunction fast_divide_(CFunction::Make(FastDivide));static void Initialize(Local&lt;Object&gt; target, Local&lt;Value&gt; unused, Local&lt;Context&gt; context, void* priv) &#123; // SetMethodNoSideEffect(context, target, &quot;divide&quot;, SlowDivide); SetFastMethod(context, target, &quot;divide&quot;, SlowDivide, &amp;fast_divide_);&#125; 3. Snapshot을 위한 등록어떤 API를 Snapshot으로 만들어야할지 직접 코드상에서 등록해야한다. 123456// Snapshotvoid RegisterExternalReferences(ExternalReferenceRegistry* registry) &#123; registry-&gt;Register(SlowDivide); registry-&gt;Register(FastDivide); registry-&gt;Register(fast_divide_.GetTypeInfo());&#125; Reference buffer: use v8 fast API calls for Buffer.byteLength with sequential one-byte strings timers: use V8 fast API calls adding-v8-fast-api.md","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"V8 Fast API에 대하여 1","slug":"article-2023-08-06-fast-api-1","date":"2023-08-06T05:09:42.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-08-06-fast-api-1/","link":"","permalink":"https://llnm.github.io/article/2023-08-06-fast-api-1/","excerpt":"","text":"V8 Fast API V8 JavaScript 엔진은 JIT 컴파일을 수행할 수 있는 JavaScript 엔진이다. 그런데, 이런 JIT에서 얻을 수 있는 최적화 장점이 C++ Binding에는 적용되기 어렵다. 그래서 매번 C++ 과 JS를 오가며 변환, 설정 과정이 수반되는 Call을 불러야했다. 그로인한 성능의 저하가 있었다. JIT(Just-In-Time) 컴파일은 프로그램을 실행하는 동안 실제로 필요한 코드 부분만 컴파일하는 기술이다. 일반적으로 JavaScript 코드는 한 줄씩 인터프리터에 의해 해석되지만, JIT 컴파일러는 자주 사용되는 함수나 루프 같은 핵심 코드를 미리 컴파일하고 최적화하여 실행 속도를 높인다. Fast API 는 C++ 바인딩 코드에 대해서도 IR 코드로 전환될 수 있도록 지원하는 기능이다. 향후 C++ 코드를 부르지 않기 때문에 빠를 수 밖에 없다. 그러나 모든 V8 모든 C++ API 에 대해서 지원하는 것은 아니고 사용에 따른 제약이 존재한다. 제약사항Fast API가 도입되었던 시기의 제약사항은 다음과 같았다. 현재에는 어떻게 달라졌는지 확인해볼것이지만 아마 핵심적인 컨셉은 변경되지 않을 것이다. 1. JS Heap에 할당되서는 안된다JS Heap은 가비지 컬렉션에 의해 관리되는데 이는 성능에 부담을 일으킬수 있는 작업이고 메모리 할당 또한 마찬가지다. 성능을 향상시키기 위한 제약조건으로 보여진다. 실 예로 따지면 v8::Array::Get() or v8::Number::New() 와 같은 작업을 할 수 없다. 2. JS 코드를 다시 호출해서는 안된다C++ 코드가 다시 JS 코드를 호출하면 안된다. JIT 컴파일러가 생성한 최적화된 코드 내에서 다시 JavaScript 코드를 호출하거나 실행하면 안 된다는 원칙을 나타낸다. 예를 들어, JIT 컴파일러가 일부 코드를 최적화하고 기계 코드를 생성하였는데, 그 중에 JavaScript 함수를 호출하는 부분이 있다고 가정해보자. 이렇게 되면 기계 코드 내에서 JavaScript 엔진의 실행 흐름을 따라가야 하므로 최적화된 코드의 성능 향상 효과가 상쇄될 수 있다. 따라서 Fast API 코드 내에서 JavaScript 코드 호출을 허용하지 않고, 순수한 기계 코드로만 구성되도록 보장한다. 이렇게 함으로써 최적화된 코드의 성능 개선 효과를 유지하면서 예측 가능하고 안정적인 실행을 보장한다. 3. 에러를 Throw 하는 것도 허용되지 않는다마찬가지로 Error 처리하는데 속도문제가 있을것으로 생각된다. Fast API를 등록할때, fallback 도 등록하게 되는데, Error Throwing이 필요한 경우 fallback api (Slow API) 에서 작업하면 된다. 4. 모든 Input type과 return type 지원하는것이 아니다현재 지원하는 코드에 대해서는 아래의 코드에서 확인할 수 있다. v8-fast-api-calls.hlink150151152153154155156157158159160161162163164165166* Currently supported return types:* - void* - bool* - int32_t* - uint32_t* - float32_t* - float64_t* Currently supported argument types:* - pointer to an embedder type* - JavaScript array of primitive types* - bool* - int32_t* - uint32_t* - int64_t* - uint64_t* - float32_t* - float64_t Related links 46619 - add SetFastMethodNoSideEffect() 46616 - buffer: use v8 fast API calls for Buffer.byteLength with sequential one-byte strings","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Split strings containing Korean and English into tokens","slug":"article-2023-08-02-tokenize-multi-lang","date":"2023-08-01T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-08-02-tokenize-multi-lang/","link":"","permalink":"https://llnm.github.io/article/2023-08-02-tokenize-multi-lang/","excerpt":"","text":"How can we tokenize a string into a list based on language? For example, if the string is &quot;hi 안녕하세요 반가워요 hello&quot;, the resulting list should be [&quot;hi&quot;, &quot;안녕하세요 반가워요&quot;, &quot;hello&quot;]. To tokenize a string to a list by language, we can use a similar approach as before using regular expressions to tokenize the text based on the Unicode character properties. Here&#39;s an example code snippet that tokenizes a string to a list by language using regular expressions: 1234567891011121314151617181920import re# set the input stringinput_string = &#x27;hi 안녕하세요 반가워요 hello&#x27;# detect the language of the input stringif re.search(&#x27;[\\u3131-\\u3163\\uac00-\\ud7a3]+&#x27;, input_string): language = &#x27;korean&#x27;else: language = &#x27;english&#x27;# tokenize the input string using the appropriate regular expressionif language == &#x27;korean&#x27;: tokens = re.findall(&#x27;[^\\s]+&#x27;, input_string) tokens = [re.sub(r&#x27;([^\\w\\s]|_)+&#x27;, &#x27;&#x27;, token) for token in tokens]else: tokens = re.findall(r&#x27;\\w+&#x27;, input_string)# output the resulting list of tokensprint(tokens) This will output the following list of tokens: [&#39;hi&#39;, &#39;안녕하세요 반가워요&#39;, &#39;hello&#39;]. Note that for Korean text, we use the regular expression [^\\s]+ to match any sequence of non-whitespace characters, which includes punctuation symbols such as period and comma. We then use the re.sub function to remove any remaining punctuation from each token.","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[]},{"title":"Mechanism over Policy","slug":"talk-2023-07-29-mechanism-over-policy","date":"2023-07-29T04:18:44.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"talk/2023-07-29-mechanism-over-policy/","link":"","permalink":"https://llnm.github.io/talk/2023-07-29-mechanism-over-policy/","excerpt":"","text":"Node.js의 dotenv 기능과 관련된 최근 Pull Request 리뷰를 진행하다 Ben Noordhuis의 견해로부터 작은 깨달음을 얻었습니다. 그는 해당 기능이 정책에 과도한 초점을 두면서 유연성을 잃을 수 있다고 우려했습니다. 처음에는 그의 의견을 완전히 이해하기 어려웠지만, 점차 고민해보면서 그의 의도를 파악할 수 있었습니다. 소프트웨어 디자인 단계에서 &quot;정책 우선 메커니즘&quot;과 &quot;메커니즘 우선 정책&quot;이라는 두 가지 접근법 간의 대립을 자주 마주하게 됩니다. 전자는 정책을 먼저 결정하고 그에 따라 시스템을 설계하는 방식이며, 후자는 시스템의 기본 메커니즘을 먼저 구축한 다음 정책을 나중에 조정하는 방식입니다. 시스템을 개발할 때 정책을 우선 결정하면 초기부터 제한된 틀 안에서 작업해야 합니다. 정책이 변경되면 시스템 전체를 다시 설계해야 할 수도 있습니다. 그러나 &quot;메커니즘 우선 정책&quot;의 접근법은 더 유연한 방식을 제공합니다. 물론 모든 상황에서 메커니즘의 유연성을 우선시할 수 없지만, 소프트웨어 환경은 지속적으로 변화하기 때문에 초기에 정책을 결정하고 이를 기반으로 시스템을 설계하는 것이 나중에 변경하기 어려울 수 있음을 미리 인식하는 것이 중요하다는 그의 의견에 공감했습니다. 앞으로 시스템을 설계할 때 항상 이를 염두에 두어야겠다는 생각이 들었습니다. 관련 PR: https://github.com/nodejs/node/pull/48890","categories":[{"name":"talk","slug":"talk","permalink":"https://llnm.github.io/categories/talk/"}],"tags":[]},{"title":"Transferable 객체의 새로운 정의 방법","slug":"article-2023-07-24-node-transferable","date":"2023-07-23T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-07-24-node-transferable/","link":"","permalink":"https://llnm.github.io/article/2023-07-24-node-transferable/","excerpt":"","text":"컨텍스트 간 사용자 정의 객체 전달MessagePort는 서로 다른 컨텍스트 간에 메시지를 교환하기 위한 메커니즘입니다. V8 자바스크립트 엔진은 기본 객체들의 컨텍스트 간 이동 시 직렬화와 역직렬화 방법을 제공하며, 사용자 객체에 대해서도 직렬화와 역직렬화를 위한 인터페이스를 제공합니다. 그러나 V8이 기존에 제공하던 이러한 인터페이스에는 문제점이 있어, Web 호환성 API 등의 기능을 구현할 때 성능 저하가 발생할 수 있었습니다. 이에 대한 개선을 위한 제안이 등장하여 해당 제안을 검토해보았습니다. 기존 방법Transferable objectsTransferable object는 한 컨텍스트에서 다른 컨텍스트로 전송 가능한 리소스를 포함하는 객체입니다. 이 객체는 전송하는 컨텍스트를 벗어난 후에는 사용할 수 없으며, 다른 컨텍스트에서만 활용 가능합니다. 객체를 전송한 후에는 해당 컨텍스트에서 더 이상 사용할 수 없으며, 전송된 객체를 사용하려고 시도하면 에러가 발생합니다. 예를 들어, ArrayBuffer를 전송하는 경우 내부 버퍼가 분리되어 전송되며, 이후에 해당 버퍼에 접근하려고 하면 에러가 발생할 수 있습니다. 12345let ab = new ArrayBuffer(1);worker.postMessage(ab, [ab]);if (ab.byteLength == 0) &#123; // ab is transferred.&#125; 예: ArrayBuffer, MessagePort, ReadableStream, WritableStream, TransformStream, and so on. HTML Structured clone algorithmpostMessage() 함수 내부에서 객체를 전송할 때에는 structured clone algorithm를 이 호출됩니다. 이 알고리즘이 지원하는 객체는 일반 반 객체로 한정하여 처리하며, 사용자가 별도로 정의한 Class와 같은 객체는 전송이 지원되지 않습니다. Transferable in Node.js이 알고리즘을 따라 일관된 형식으로 객체를 전송 가능하도록 만들기 위해서는 사용자 정의 객체를 Host Object로 취급되게 해야 합니다. 객체가 Host Object로 인식되면 V8 엔진은 사용자가 제공한 Serialize&#x2F;Deserialize 대리자를 호출합니다. 문제는 Native 계층에서는 객체를 Host Object로 인식시키는 것이 가능하지만, JavaScript 계층에서는 이를 수행할 방법이 없었습니다. 이에 따라, Native 층에서 JSTransferable 클래스를 생성하고 이를 JavaScript 객체 프로토타입 체인의 상위에 등록하여 Host Object로 인식되도록 했습니다. 그리고 해당 클래스에 Private Symbol ([kTransfer], [kClone], [kDeserialize])을 이용한 함수를 구현하여 Serialize 및 Deserialize 작업이 해당 클래스의 대리자로 호출되도록 구현했습니다. 또 다른 문제는 WritableStream 및 ReadableStream과 같은 Web API가 표준에서 다른 클래스를 상속하도록 정의되어 있지 않아, JSTransferable로 이러한 클래스를 확장할 수 없었습니다. 이를 해결하기 위해 makeTransferable이라는 일종의 해킹 함수를 사용하여 상속 관계를 조작했습니다. 이 방식은 표준을 올바르게 구현하는 방법이긴 하지만, 인스턴스가 생성될 때마다 makeTransferable 함수가 호출되기 때문에 성능 측면에서는 좋지 않을 수 있었습니다. 12345678910111213141516function makeTransferable(obj) &#123; // If the object is already transferable, skip all this. if (obj instanceof JSTransferable) return obj; const inst = ReflectConstruct(JSTransferable, [], obj.constructor); const properties = ObjectGetOwnPropertyDescriptors(obj); const propertiesValues = ObjectValues(properties); for (let i = 0; i &lt; propertiesValues.length; i++) &#123; // We want to use null-prototype objects to not rely on globally mutable // %Object.prototype%. ObjectSetPrototypeOf(propertiesValues[i], null); &#125; ObjectDefineProperties(inst, properties); ObjectSetPrototypeOf(inst, ObjectGetPrototypeOf(obj)); return inst;&#125; 새로운 방법markTransferMode앞에서 언급한 성능 문제를 개선하기 위해 새로운 패치가 적용되었습니다. JavaScript 객체에 대해서도 Host Object로 인식할 수 있도록 하기 위해 transfer_mode_private_symbol을 이용하는 방법이 도입되었습니다. 또한, V8 엔진에서 기존에 Host Object를 판단하는 방식으로 EmbedderFieldCount를 확인하던 것을 명시적으로 판단할 수 있도록 하기 위해 IsHostObject() 인터페이스가 추가되었습니다. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// node/lib/internal/worker/js_transferable.js/** * Mark an object as being transferable or customized cloneable in * `.postMessage()`. * This should only applied to host objects like Web API interfaces, Node.js&#x27; * built-in objects. * Objects marked as cloneable and transferable should implement the method * `@@kClone` and `@@kTransfer` respectively. Method `@@kDeserialize` is * required to deserialize the data to a new instance. * * Example implementation of a cloneable interface (assuming its located in * `internal/my_interface.js`): * * ``` * class MyInterface &#123; * constructor(...args) &#123; * markTransferMode(this, true); // &lt;-- * this.args = args; * &#125; * [kDeserialize](data) &#123; * this.args = data.args; * &#125; * [kClone]() &#123; * return &#123; * data: &#123; args: this.args &#125;, * deserializeInfo: &#x27;internal/my_interface:MyInterface&#x27;, * &#125; * &#125; * &#125; * * module.exports = &#123; * MyInterface, * &#125;; * ``` * @param &#123;object&#125; obj Host objects that can be either cloned or transferred. * @param &#123;boolean&#125; [cloneable] if the object can be cloned and `@@kClone` is * implemented. * @param &#123;boolean&#125; [transferable] if the object can be transferred and * `@@kTransfer` is implemented. */function markTransferMode(obj, cloneable = false, transferable = false) &#123; if ((typeof obj !== &#x27;object&#x27; &amp;&amp; typeof obj !== &#x27;function&#x27;) || obj === null) return; // This object is a primitive and therefore already untransferable. let mode = kDisallowCloneAndTransfer; if (cloneable) mode |= kCloneable; if (transferable) mode |= kTransferable; obj[transfer_mode_private_symbol] = mode; // &lt;--&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// src/node_messaging.cc// staticbool JSTransferable::IsJSTransferable(Environment* env, v8::Local&lt;v8::Context&gt; context, v8::Local&lt;v8::Object&gt; object) &#123; return object-&gt;HasPrivate(context, env-&gt;transfer_mode_private_symbol()) // &lt;-- .ToChecked();&#125;// Provide a wrapper class created when a built-in JS classes that being// transferable or cloneable by postMessage().// See e.g. FileHandle in internal/fs/promises.js for an example.class JSTransferable : public BaseObject &#123; public: static JSTransferable* Wrap(Environment* env, v8::Local&lt;v8::Object&gt; target); static bool IsJSTransferable(Environment* env, v8::Local&lt;v8::Context&gt; context, v8::Local&lt;v8::Object&gt; object);&#125;// This tells V8 how to serialize objects that it does not understand// (e.g. C++ objects) into the output buffer, in a way that our own// DeserializerDelegate understands how to unpack.class SerializerDelegate : public ValueSerializer::Delegate &#123; ... bool HasCustomHostObject(Isolate* isolate) override &#123; return true; &#125; Maybe&lt;bool&gt; IsHostObject(Isolate* isolate, Local&lt;Object&gt; object) override &#123; if (BaseObject::IsBaseObject(object)) &#123; return Just(true); &#125; return Just(JSTransferable::IsJSTransferable(env_, context_, object)); // &lt;-- &#125; Maybe&lt;bool&gt; WriteHostObject(Isolate* isolate, Local&lt;Object&gt; object) override &#123; if (BaseObject::IsBaseObject(object)) &#123; return WriteHostObject( BaseObjectPtr&lt;BaseObject&gt; &#123; Unwrap&lt;BaseObject&gt;(object) &#125;); &#125; if (JSTransferable::IsJSTransferable(env_, context_, object)) &#123; JSTransferable* js_transferable = JSTransferable::Wrap(env_, object); return WriteHostObject(BaseObjectPtr&lt;BaseObject&gt;&#123;js_transferable&#125;); &#125; ... &#125;&#125;// This is used to tell V8 how to read transferred host objects, like other// `MessagePort`s and `SharedArrayBuffer`s, and make new JS objects out of them.class DeserializerDelegate : public ValueDeserializer::Delegate &#123; ... MaybeLocal&lt;Object&gt; ReadHostObject(Isolate* isolate) override &#123; // Identifying the index in the message&#x27;s BaseObject array is sufficient. uint32_t id; if (!deserializer-&gt;ReadUint32(&amp;id)) return MaybeLocal&lt;Object&gt;(); if (id != kNormalObject) &#123; CHECK_LT(id, host_objects_.size()); Local&lt;Object&gt; object = host_objects_[id]-&gt;object(isolate); if (env_-&gt;js_transferable_constructor_template()-&gt;HasInstance(object)) &#123; return Unwrap&lt;JSTransferable&gt;(object)-&gt;target(); &#125; else &#123; return object; &#125; &#125; ... &#125;&#125; V812345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// deps/v8/include/v8-value-serializer.h/** * Value serialization compatible with the HTML structured clone algorithm. * The format is backward-compatible (i.e. safe to store to disk). */class V8_EXPORT ValueSerializer &#123; /** * The embedder overrides this method to enable custom host object filter * with Delegate::IsHostObject. * * This method is called at most once per serializer. */ virtual bool HasCustomHostObject(Isolate* isolate); /** * The embedder overrides this method to determine if an JS object is a * host object and needs to be serialized by the host. */ virtual Maybe&lt;bool&gt; IsHostObject(Isolate* isolate, Local&lt;Object&gt; object);&#125;;// deps/v8/src/api/api.ccbool ValueSerializer::Delegate::HasCustomHostObject(Isolate* v8_isolate) &#123; return false;&#125;Maybe&lt;bool&gt; ValueSerializer::Delegate::IsHostObject(Isolate* v8_isolate, Local&lt;Object&gt; object) &#123; i::Isolate* i_isolate = reinterpret_cast&lt;i::Isolate*&gt;(v8_isolate); i::Handle&lt;i::JSObject&gt; js_object = i::Handle&lt;i::JSObject&gt;::cast(Utils::OpenHandle(*object)); return Just&lt;bool&gt;( i::JSObject::GetEmbedderFieldCount(js_object-&gt;map(i_isolate)));&#125;// deps/v8/src/objects/value-serializer.ccValueSerializer::ValueSerializer(Isolate* isolate, v8::ValueSerializer::Delegate* delegate) : isolate_(isolate), delegate_(delegate), zone_(isolate-&gt;allocator(), ZONE_NAME), id_map_(isolate-&gt;heap(), ZoneAllocationPolicy(&amp;zone_)), array_buffer_transfer_map_(isolate-&gt;heap(), ZoneAllocationPolicy(&amp;zone_)) &#123; if (delegate_) &#123; v8::Isolate* v8_isolate = reinterpret_cast&lt;v8::Isolate*&gt;(isolate_); has_custom_host_objects_ = delegate_-&gt;HasCustomHostObject(v8_isolate); &#125;&#125;// 이전에 Host Object를 구별하는 방법이 EmbedderFieldCount를 확인하는 방법이었다면// 명시적으로 이를 확인하는 방법을 추가하였다.Maybe&lt;bool&gt; ValueSerializer::WriteJSReceiver(Handle&lt;JSReceiver&gt; receiver) &#123; ... HandleScope scope(isolate_); switch (instance_type) &#123; case JS_ARRAY_TYPE: return WriteJSArray(Handle&lt;JSArray&gt;::cast(receiver)); ... case JS_API_OBJECT_TYPE: &#123; Handle&lt;JSObject&gt; js_object = Handle&lt;JSObject&gt;::cast(receiver); // if (JSObject::GetEmbedderFieldCount(js_object-&gt;map(isolate_))) &#123; // - Maybe&lt;bool&gt; is_host_object = IsHostObject(js_object); // + if (is_host_object.IsNothing()) &#123; // + return is_host_object; // + &#125; // + if (is_host_object.FromJust()) &#123; // + return WriteHostObject(js_object); &#125; else &#123; return WriteJSObject(js_object); &#125; &#125; &#125;&#125;Maybe&lt;bool&gt; ValueSerializer::IsHostObject(Handle&lt;JSObject&gt; js_object) &#123; if (!has_custom_host_objects_) &#123; return Just&lt;bool&gt;( JSObject::GetEmbedderFieldCount(js_object-&gt;map(isolate_))); &#125; DCHECK_NOT_NULL(delegate_); v8::Isolate* v8_isolate = reinterpret_cast&lt;v8::Isolate*&gt;(isolate_); Maybe&lt;bool&gt; result = delegate_-&gt;IsHostObject(v8_isolate, Utils::ToLocal(js_object)); // &lt;-- RETURN_VALUE_IF_SCHEDULED_EXCEPTION(isolate_, Nothing&lt;bool&gt;()); DCHECK(!result.IsNothing()); if (V8_UNLIKELY(out_of_memory_)) return ThrowIfOutOfMemory(); return result;&#125; References make JSTransferables based on private symbols Userland transferable&#x2F;cloneable objects makeTransferable https://github.com/nodejs/performance/issues/82#issuecomment-1613378037 https://developer.chrome.com/blog/transferable-objects-lightning-fast/","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://llnm.github.io/tags/node-js/"}]},{"title":"Automated semantic versioning based on commits.","slug":"article-2023-07-16-automated-semver","date":"2023-07-15T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-07-16-automated-semver/","link":"","permalink":"https://llnm.github.io/article/2023-07-16-automated-semver/","excerpt":"","text":"I wondered if there was a way to automatically update the patch version of SemVer when a commit is made. I tried to make it using the commit hook in python. Create a version.py file with a variable to store the version: 12# version.py__version__ = &#x27;0.1.0&#x27; Add a pre-commit hook script that updates the version in the version.py file: 12345678910111213141516# .git/hooks/pre-commit#!/bin/bash# Get the current version from version.pyVERSION=$(sed -nE &#x27;s/^__version__ = (\\x27|\\&quot;)(.*)\\1$/\\2/p&#x27; version.py)# Increment the patch numberPATCH=$(echo $VERSION | awk -F. &#x27;&#123;print $3&#125;&#x27;)NEW_PATCH=$(expr $PATCH + 1)NEW_VERSION=$(echo $VERSION | awk -F. -v new_patch=&quot;$NEW_PATCH&quot; &#x27;&#123;$3=new_patch; OFS=&quot;.&quot;; print $1,$2,$3&#125;&#x27;)# Update the version in version.pysed -i &#x27;&#x27; -E &quot;s/^__version__ = (\\x27|\\&quot;).*(\\x27|\\&quot;)/__version__ = \\&#x27;$NEW_VERSION\\&#x27;/&quot; version.py# Stage the updated version.py file for commitgit add version.py This script gets the current version number from the version.py file, increments the patch number, updates the version in version.py, and stages the file for commit. Make the pre-commit hook script executable: 1chmod +x .git/hooks/pre-commit Now, when you make a commit, the pre-commit hook script will automatically update the version in version.py. You can use the __version__ variable in your Python code to refer to the current version number. For example: 1234# main.pyimport versionprint(&#x27;MyApp version &#123;&#125;&#x27;.format(version.__version__)) This will output MyApp version 0.1.1 if the latest commit incremented the patch number.","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[{"name":"python","slug":"python","permalink":"https://llnm.github.io/tags/python/"}]},{"title":"Linux I/O 성능 혁신 - io_uring","slug":"article-2023-07-14-io-uring","date":"2023-07-13T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-07-14-io-uring/","link":"","permalink":"https://llnm.github.io/article/2023-07-14-io-uring/","excerpt":"","text":"2019년에 소개된 io_uring은 Linux 커널을 위한 비동기 I&#x2F;O 인터페이스입니다. 기존 인터페이스인 epoll&#x2F;kqueue와 aio 대비하여 뛰어난 성능과 간결하고 직관적인 API 사용성을 제공합니다. io_uring은 비동기 I&#x2F;O, 시스템 콜의 다중 배치 처리, 유연한 버퍼 관리 등을 통해 Linux I&#x2F;O 모델의 중요한 발전 중 하나로 인정받고 있습니다. 주요 특징동작 원리io_uring은 사용자와 커널 간의 공유 메모리 내에 원형 큐 (queue rings)를 활용합니다. 제출큐 (Submission Queue)와 완료큐 (Completion Queue)로 구성된 이러한 큐를 통해 사용자는 여러 개의 I&#x2F;O 작업을 스케줄링할 수 있습니다. 커널은 스케줄된 작업을 처리하고 그 결과를 완료큐에 반환하여 사용자가 결과를 처리할 수 있도록 합니다. 우수한 성능io_uring은 사용자와 커널 간의 공유 메모리를 이용하여 Zero-Copy I&#x2F;O를 지원합니다. 또한 사용자가 I&#x2F;O 작업을 스케줄링할 때 필요한 모든 정보를 커널에 전달하고 커널 내에서 작업 완료를 관리함으로써 추가적인 사용자&#x2F;커널 간 컨텍스트 스위칭(context switching)을 최소화합니다. 이로써 전통적인 동기 I&#x2F;O에 비해 더 낮은 오버헤드를 가지게 됩니다. 간결한 인터페이스기존의 epoll에서는 여러 개의 입출력 작업(multiplexing)을 위해 파일 디스크립터의 상태를 필터링해야 했습니다. 반면 io_uring은 더 간결한 사용 방식을 제공합니다. 사용자는 io_uring_enter() 함수를 호출하여 시스템 콜을 커널에 스케줄링하고 결과를 처리합니다. 이러한 방식은 Polling과 Interrupt-driven I&#x2F;O를 모두 지원합니다. epoll을 사용한 설정123456789101112131415161718...int epoll_fd = epoll_create1(0);struct epoll_event event;event.events = EPOLLIN; // 읽기 이벤트 설정event.data.fd = sockfd; // 관심 있는 파일 디스크립터 설정epoll_ctl(epoll_fd, EPOLL_CTL_ADD, sockfd, &amp;event);struct epoll_event events[MAX_EVENTS];int ready_fds = epoll_wait(epoll_fd, events, MAX_EVENTS, timeout);for (int i = 0; i &lt; ready_fds; i++) &#123; int fd = events[i].data.fd; if (events[i].events &amp; EPOLLIN) &#123; // 읽기 이벤트 처리 // ... &#125;&#125; io_uring을 사용한 설정123456789101112131415161718192021#include &lt;liburing.h&gt;...struct io_uring ring;io_uring_queue_init(QUEUE_DEPTH, &amp;ring, 0);struct io_uring_sqe *sqe = io_uring_get_sqe(&amp;ring);io_uring_prep_read(sqe, sockfd, buf, buflen, offset);io_uring_submit(&amp;ring);struct io_uring_cqe *cqe;int ret = io_uring_wait_cqe(&amp;ring, &amp;cqe);if (ret &gt;= 0) &#123; if (cqe-&gt;res &gt;= 0) &#123; // 성공 &#125; else &#123; // 에러 &#125; io_uring_cqe_seen(&amp;ring, cqe);&#125; 생각libuv에서도 io uring API를 사용할 수 있게 되었습니다. 현재는 파일 연산에 한정되어 있지만, io_uring을 지원하는 커널의 경우 파일 연산 처리량이 최대 8배까지 증가하는 것으로 확인되었습니다. 파일 연산이 많거나 파일과 네트워크 I&#x2F;O 워크로드가 혼합된 시스템에서는 io_uring의 사용으로 비약적인 성능 향상이 가능할 것으로 보입니다. 이러한 잠재력을 고려하여 io_uring을 활용하는 것이 유용할 것입니다. References deps: upgrade to libuv 1.46.0 New kernel polling interface for Linux 4.18 (io_uring)?","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://llnm.github.io/tags/node-js/"}]},{"title":"Node.js 활용 사례 - Netflix","slug":"article-2023-07-07-nodejs-usecase-netflix","date":"2023-07-07T01:31:10.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"article/2023-07-07-nodejs-usecase-netflix/","link":"","permalink":"https://llnm.github.io/article/2023-07-07-nodejs-usecase-netflix/","excerpt":"","text":"2009년 Node.js가 등장한 이래 Node.js는 현대 소프트웨어 개발에서 매우 중요한 역할을 하고 있습니다. 그러한 역할은 산업 전반의 다양한 활용 사례를 통해 입증되고 있습니다. 이 글은 그 활용 사례중 한 도입 사례를 한 발 더 깊이 연구해봅니다. 무엇이 문제였는지, 그리고 그 문제 해결에 어떻게 도움이 되었는지 확인해 봄으로서 Node.js의 가치를 좀 더 가늠해 보려합니다. 배경넷플릭스는 2015년경부터 자사의 앱 스택에 Node.js를 적용하는데 그 당시 Netflix는 사용자 사용 앱의 &#39;익터랙티브 시간&#39; (TTI: Time To Interactive) 를 줄이고자 하는 목표를 가지고 있었습니다. &#39;익터랙티브 시간&#39; 이란 어플리케이션 최초 시작 시점부터 UI 가 사용자에 의해 상호작용이 가능한 시간까지의 첫 시점을 의미합니다. 이 TTI라는 지표를 원하는 수치 달성하기 위해 개선에 집중한 영역은 아래와 같았습니다. 서버 랜더링 - 클라이언트 렌더링, 그리고 Universal Javascript웹 어플리케이션을 작성할때 애플리케이션의 특성과 요구사항에 따라 서버 혹은 클라이언트 렌더링을 고려해 설계합니다. 서버 렌더링(Server-side rendering)은 웹 애플리케이션에서 클라이언트 측에서 화면을 구성하는 대신 서버에서 HTML을 생성하여 클라이언트에게 제공하는 방식입니다. 이는 클라이언트 측에서 자바스크립트를 실행하여 화면을 동적으로 렌더링하는 클라이언트 사이드 렌더링(Client-side rendering)과 대조적인 방법입니다. 서버 렌더링은 서버 측에서 마크업을 생성하므로 초기 로딩 속도가 개선될 수 있습니다. 사용자는 초기 페이지 로드 후에 즉시 내용을 볼 수 있으며, 검색 엔진 최적화 (SEO)에도 도움이 될 수 있습니다. 클라이언트 렌더링은 JavaScript를 사용하여 동적인 UI를 쉽게 구현할 수 있습니다. 사용자의 상호작용에 따라 즉각적인 업데이트와 상태 변경이 가능하며, 더 나은 사용자 경험을 제공할 수 있습니다. 서버 렌더링, 클라이언트 렌더링은 프로젝트의 목표, 성능 요구사항, 개발자 경험 및 유지 보수 등을 고려하여 결정해야하나 넷플릭스가 Node.js 도입시 가졌던 문제는 이러한 서버 렌더링과 클라이언트 렌더링을 유연하게 설계하는 것이 어려웠던 것이었습니다. 그리고 그 어려움의 가장 큰 이유가 양측에서 사용하는 언어가 서로 다른 점이었습니다. 두 언어를 상호 전환하는 데에는 기본적으로 비용을 수반하며, 렌더링을 유연하기 위해 마크업을 개선하기 위해서는 클라이언트 코드와 너무 많은 직접적인 커플링이 발생합니다. 이에 대한 여러 솔루션이 있으나 양쪽이 같은 언어를 사용했을때 언어의 다름으로 인해 렌더링 결과의 미세한 차이가 발생 할 수 있는 있다는 것을 확인하였으며 이로 인해 모든 마크업이 동일 언어에서 제공하는 한 API를 사용하여 구성하는 것이 이상적이다라고 판단하게 되었습니다. Monolithic 아키텍쳐에서 Service 기반 아키텍쳐로Monolithic 은 &quot;하나로 통합된&quot; 이라는 의미를 가지며, 애플리케이션의 모든 구성 요소가 단일한 실행 가능한 단위로 구성되는 것을 의미합니다. 일반적으로 단일 코드베이스로 구성되며, 모든 기능과 서비스가 하나의 애플리케이션 내에 존재합니다. Netflix는 기존 앱은 Monolithic 한 형태로 설계되어 있었으며 [[Java EE]] (자바 엔터프라이즈 에디션) 기반으로 작성되어 있었습니다. 엔터프라이즈 자바(Enterprise Java)는 기업 환경에서 대규모 응용 프로그램을 개발하고 구축하는 데 사용되는 자바 기반의 기술과 플랫폼을 가리킵니다. 엔터프라이즈 자바는 자바 엔터프라이즈 에디션(Java EE) 스펙의 일부로 제공되며, 기업급 시스템에서 안정성, 확장성, 보안성 등의 요구사항을 충족시키기 위한 다양한 기능과 도구를 제공합니다. 또 자체 데이터 서버를 가지고 있어 서버, 스토리지, 네트워크 장비 등을 직접 관리하였습니다. 이러한 데이터 서버 유지 및 스케일링에 대한 관리 비용을 효율화하고자, 인터넷 컴퓨터 리소스인 클라우드를 활용하기로 결정하였습니다. Monolithic 아키텍처는 전체 어플리케이션을 단일 단위로 배포하고 실행합니다. 그렇기 때문에 클라우드 환경에서는 기능의 독립적인 확장이 어렵고, 전체 어플리케이션을 확장해야하기 때문에 리소스 사용이 비효율적일 수 있습니다. 또 개발 및 배포가 어렵고, 장애발생시 회복시키거나 장애를 격리하기가 어렵습니다. 이러한 이유로인해 Netflix는 기존의 Monolithic Java 서비스 였던 애플리케이션을 더 작은 집합 (Microservice)으로 해체하고자 하였습니다. Node.js 와 React.js상기 두 개선 영역을 해결하고자 넷플릭스는 Node.js와 React.js를 도입하였습니다. Node.js 런타임내 React.js를 사용하여 서버와 클라이언트의 렌더링 로직을 공유할 수 있었습니다. 예를 들어, React 컴포넌트를 서버 측에서 렌더링하여 초기 마크업을 생성한 후, 클라이언트에서는 해당 컴포넌트를 가져와 상호작용을 처리하고 동적으로 업데이트할 수 있습니다. 이를 통해 서버와 클라이언트 간에 렌더링 로직을 공유하여 일관성을 유지하고 개발 유연성, 생산성을 향상시킬 수 있습니다. 또 Monolithic Java 서비스를 해체하여 구동하는데 Node.js를 활용하였는데, 그 이유중 하나는 Node.js 가 마이크로 서비스 구축에 적합한 솔루션이였기 때문이었습니다. Node.js는 싱글 스레드 이벤트 큐로 구성된 &#39;Event-Driven&#39; 아키텍쳐를 가지고 있습니다. 이러한 구조는 비동기 I&#x2F;O 처리를 위해 많은 수의 동시 요청을 처리할 수 있으며, 이벤트가 발생할 때 다른 서비스나 외부 시스템과의 상호작용을 단순화 할 수 있습니다. Java 기반 애플리케이션 대비 시스템 구동, 통신등에 있어 자원 사용 및 오버헤드가 적다는 것도 마이크로 서비스간 빈번한 상호작용과 빠른 응답성에도 유리하였습니다. 결론활용사례를 조사해보며 해당 기업이 Node.js를 도입하고자 했던 문제와 가치를 좀 더 잘 이해할 수 있었습니다. 비슷한 문제를 가진 프로젝트와 기업에서도 Node.js를 솔루션으로서 고려해 볼 수 있을것 입니다. 또한 어떤 한 솔루션이 프로덕션 레벨의 기술 스택으로 사용되기 위해서는 여러 가지 신뢰성과 관련된 의문을 해결해야 하는데, 조사를 하며 Netflix를 비롯하여 이미 많은 회사에서 Node.js를 자사 서비스 구조의 주요 축으로서 성공적으로 적용한 사례가 있었습니다. 이는 현재 Javascript 런타임이 다양하게 등장하고 있는 시대에 있어서 솔루션 선택에 있어서 중요한 지표가 될 수 있다고 생각됩니다. 아래 다른 적용 사례에 대한 리스트를 첨부합니다 NASA: https://openjsf.org/wp-content/uploads/sites/84/2020/02/Case_Study-Node.js-NASA.pdf Uber: https://www.uber.com/en-IN/blog/uber-tech-stack-part-two/ ebay: https://clinejj.medium.com/building-with-node-js-at-ebay-9bbdf7d79b82 Paypal: https://medium.com/paypal-tech/node-js-at-paypal-4e2d1d08ce4f","categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://llnm.github.io/tags/node-js/"}]},{"title":"ChatGPT","slug":"talk-2023-07-03-chatgpt","date":"2023-07-02T15:00:00.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"talk/2023-07-03-chatgpt/","link":"","permalink":"https://llnm.github.io/talk/2023-07-03-chatgpt/","excerpt":"","text":"최근 ChatGPT가 너무나 충격적이어서 나의 언어로 이것이 무엇인지 기술해보기로 했다. 아래는 내가 정리해본 내용이다. ChatGPT는 OpenAI에서 개발한 대화형 인공지능 모델인 GPT를 기반으로 한 챗봇입니다. GPT 모델은 자연어 처리 기술을 활용하여 다양한 언어 작업을 수행하는 데 사용되며, 그 중에는 자연스러운 대화 또한 포함된다. 현재 최신 모델은 GPT-4이다. 이 모델을 학습시키기 위해서는 많은 양의 텍스트 데이터가 필요하다. 이러한 데이터는 인터넷에서 수집된 대화, 소설, 뉴스 기사, 블로그 포스트 등을 포함할 수 있다. 그러나 이러한 데이터를 그대로 사용할 수는 없고 데이터를 모델 학습에 용이하도록 가공하고 변환해야한다. 그 후에 모델은 이 변환된 데이터를 입력으로 활용하여 반복적으로 학습시킨다. 여기서 학습은 모델이 입력과 출력 간의 관계를 학습하여 주어진 입력에 대한 적절한 출력을 생성하도록 조정하는 과정을 의미한다. 모델은 이전 문장을 분석하여 맥락을 이해하고, 그에 기반하여 문장을 생성하는데, 생성된 문장의 오류를 최소화하기 위해 모델은 지속적으로 업데이트되며, 이러한 과정에서 대용량의 데이터가 활용된다. 학습이 어려운 경우에는 인간의 지식과 경험을 활용하여 모델의 성능을 개선하는 데 도움이 되는 강화학습(RLHF)을 활용하기도 한다. 그러나 대부분의 경우 GPT 모델은 지도학습을 기반으로 학습된다. 강화학습: 모델이 생성한 문장을 평가하고 자연스러움이나 의미적 일관성과 같은 측면에서 평가 점수를 부여. 평가 점수는 모델이 보상으로 받게 되며, 모델은 이 보상을 최대화하는 방향으로 문장 생성을 조정. 지도학습: 입력과 그에 대응하는 출력 사이의 관계를 학습하는 방법으로, 주어진 입력 데이터와 그에 대한 정답(라벨)을 활용하여 모델을 훈련시키는 프로세스. ChatGPT는 다양한 분야에서 활용될 수 있다. 특히 자연어 처리 분야에서 뛰어난 성능을 발휘하여 가상 비서와 같은 챗봇을 개발하는 데 매우 적합하다. 또한 뉴스 기사 요약, 문서 생성, 언어 번역, 코딩 등 다양한 자연어 관련 문제를 해결하는 데에도 활용될 수 있다.","categories":[{"name":"talk","slug":"talk","permalink":"https://llnm.github.io/categories/talk/"}],"tags":[{"name":"ai","slug":"ai","permalink":"https://llnm.github.io/tags/ai/"}]},{"title":"Blog 만들며 확인한 것들","slug":"talk-2023-07-01-things-about-blogging","date":"2023-07-01T03:49:02.000Z","updated":"2023-11-29T13:01:56.524Z","comments":true,"path":"talk/2023-07-01-things-about-blogging/","link":"","permalink":"https://llnm.github.io/talk/2023-07-01-things-about-blogging/","excerpt":"","text":"필요한 자료나 생각을 정리하는 것은 개인적으로 obsidian을 이용하고 있다. 대부분은 정리에 그치고 있고 특별히 정제된 포맷의 글로 작성해본 적은 없었다. 마침 기술 블로그가 필요할 수도 있는 작은 취미 생활을 하게되어 이번 기회에 하나 만들어보려 했다. 제약사항은 아래와 같이 설정했다. 호스팅은 Github page를 사용한다. Static Sites Rendering 툴을 사용한다. 2.1. 컨텐츠 갱신을 쉽게한다. 2.2. 레이아웃, 스타일 변경을 통해 약간의 사이트 개인화가 가능하다. Jekyll2.1, 2.2를 위한 후보로 Jekyll을 생각했다. 장점은 Github에서 Jekyll기반 렌더링을 지원하니 별도의 Local Jekyll 서버를 두지 않아도 렌더링이 가능하다. 그러나 2.2를 위해 수정때마다 매번 deploy를 해야하는 것은 당연히 불편한 일일 것이다. 결국 로컬 테스트 환경이 필요했다. Jekyll의 로컬환경을 만들때 마지막 렌더링을 Github에 맡긴다면 Github dependency versions에 맞춰 로컬환경을 맞춰야한다. 로컬 테스트 환경을 Portable하게 만드는 게 좋을 것 같아 Docker를 이용해보았다. 맥에서는 Ruby&#x2F;Gem이 바로 사용 가능하지만 나는 Linux&#x2F;WSL2를 주로 사용하기 때문에 필요했다. (Jekyll 로컬 테스트 환경 설정은 본문 아래에서 다룬다.) 그러나 Jekyll 테스트 환경을 구축해 보다보니 Gem과 Jekyll 사이의 dependency 관리가 좀 별로인 부분이 있었다. 굳이 렌더링을 Github에 맡겨야하는지에 대한 의문이 들었다. Github를 이용하지 않는다면 Github dependency를 맞춰야한다는 단점도 없고, 사이트 생성을 위한 코드들도 공개하지 않아도 되는 장점이 있다. 이런 생각까지 미치니 어차피 로컬 테스트 환경을 만들고 Static rendering을 할 것이면 Jekyll이 굳이 필요하지 않다고 생각되었다. 그래서 다른 후보를 찾아보니 Hexo와 Hugo가 있었다. 좀 더 익숙한 Node.js 기반의 Hexo를 테스트 해보게 되었다. HexoJavaScript Runtime 기반으로 로컬 테스트 환경을 만들수 있다 것이 가장 큰 편의성이다. Docker Container 보다 빠르게 시작할 수 있다. Jekyll 보다 후에 개발되었기 때문에 문법도 다소 현대식이고 더 합리적인것 같다. 단점은 사용자 커뮤니티에서 Non-English가 Major라는 것이다. theme에서 사용하는 기본 CSS Preprocessor가 SCSS가 아닌 Stylus라는게 다소 의아하긴했다. 물론 변경도 가능하나 Theme은 보통 기본 설정으로 구성되니 변경하는 것이 좋은 선택은 아닐 수 있다. 기타 사이트 생성시 Decoration을 위해 필요했던 외부 서비스는 아래가 있었다. Text 기반 이미지 생성 (AI Generator 아님) 실행에 큰 문제가 없었고 필요한 플러그인도 크게 부족함이 없었다. Github Action을 이용해 Deploy하는 설정은 아래 섹션에 작성하였다. Jekyll 로컬 테스트 환경Docker를 통해 interactive하게 Jekyll을 사용할 수 있도록 아래와 같은 스크립트를 작성했다. WSL2 환경에서 dockerd 실행 여부도 확인한다. 123456789101112131415#!/bin/bash# .env# MY_VOLUME=./docsif [[ $(cat /proc/version) == *&quot;WSL2&quot;* ]]; then docker_status=$(sudo service docker status) if [[ $docker_status = *&quot;Docker is not running&quot;* ]]; then sudo service docker start fifidocker compose --env-file .env up -ddocker compose exec jekyll /bin/bashdocker compose down 1234567891011121314151617# docker-compose.ymlversion: &#x27;3.8&#x27;services: jekyll: image: jekyll/jekyll volumes: - $&#123;MY_VOLUME&#125;/:/srv/jekyll - ./vendor/bundle:/usr/local/bundle ports: - &#x27;4000:4000&#x27; - &#x27;35729:35729&#x27; environment: - TZ=Asia/Seoul command: /bin/bash tty: true stdin_open: true Docker 환경에서는 아래와 같이 실행한다. 12bundle installbundle exec jekyll serve --host 0.0.0.0 --livereload Github Action을 이용한 Hexo DeployGithub Page로의 Deploy는 Github Action 이용하여 수행하도록 설정하였다. 123456789101112131415161718192021222324252627282930313233343536373839404142name: Deploy blog - JITon: push: branches: - jitjobs: build: runs-on: ubuntu-latest strategy: matrix: node-version: [20.x] steps: - uses: actions/checkout@v3 - name: Use Node.js $&#123;&#123; matrix.node-version &#125;&#125; uses: actions/setup-node@v3 with: node-version: $&#123;&#123; matrix.node-version &#125;&#125; - name: Restore cache uses: actions/cache@v3 id: node-cache with: path: &#x27;**/node_modules&#x27; key: $&#123;&#123; runner.os &#125;&#125;-node-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125; restore-keys: | $&#123;&#123; runner.os &#125;&#125;-node- - name: npm install if: steps.node-cache.outputs.cache-hit != &#x27;true&#x27; run: npm install - name: Setup Environment env: GH_TOKEN: $&#123;&#123; secrets.GH_TOKEN &#125;&#125; GIT_NAME: $&#123;&#123; vars.GIT_NAME &#125;&#125;&#125; GIT_EMAIL: $&#123;&#123; vars.GIT_EMAIL &#125;&#125;&#125; run: | git config --global user.name $&#123;GIT_NAME&#125; git config --global user.email $&#123;GIT_EMAIL&#125; sed -i &quot;s/\\$&#123;GH_TOKEN&#125;/$&#123;GH_TOKEN&#125;/&quot; _config.yml - name: Generate and Deploy Site run: | npx hexo deploy -g 생각맥OS가 아닌 환경에서 블로그 로컬 테스트 환경이 필요하면 Hexo를 사용하여 여러 OS에서 Portable하게 블로깅을 시작할 수 있다. Hexo로 환경을 구축하고, 로컬이나 CI환경을 이용해 빌드하고, 그 결과를 Deploy 하는 것을 고려해봐도 좋을 것이다. Refs: https://futurecreator.github.io/categories/Hexo","categories":[{"name":"talk","slug":"talk","permalink":"https://llnm.github.io/categories/talk/"}],"tags":[]}],"categories":[{"name":"article","slug":"article","permalink":"https://llnm.github.io/categories/article/"},{"name":"talk","slug":"talk","permalink":"https://llnm.github.io/categories/talk/"}],"tags":[{"name":"node.js","slug":"node-js","permalink":"https://llnm.github.io/tags/node-js/"},{"name":"python","slug":"python","permalink":"https://llnm.github.io/tags/python/"},{"name":"ai","slug":"ai","permalink":"https://llnm.github.io/tags/ai/"}]}